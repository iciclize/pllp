<html>
<head>
  <meta charset="utf-8"/>
  <title> x86_64 機械語入門 </title>
</head>
<style>
  pre { border: solid 1px }
  em { font-weight: bold; color: red }
  table,td,th { border: solid 1px; }
  #kokomade { color: green; }
</style>

<body>

<p> <a href="index.html"> 戻る </a> </p>

<h2> <a href="asm_language.html"> x86_64 機械語入門 </a> </h2>


<p> さて、アセンブリ言語について説明したので、せっかくなので機械語についても説明しておこう。 </p>
<p> 機械語(マシン語、machine language)は、アセンブルが終わったあとの、バイト列のことを指す。 </p>

<p>
  正直な話をすると、機械語の知識が役立つ場面はあまりない。
</p>

<p>
  アセンブリ言語の知識は、色々な場面で役立つ実用的で重要な知識であることは間違いないが、
  それと比べると、機械語への理解は、そんなに必須ではなくて、知ってたからと言って辛い場面でサバイブしやすくなるということは特にない。
</p>

<p>
  自分でアセンブラやリンカ、デバッガを作る人には重要な知識だが、OSを書く場合ですら機械語の知識が役立つ場面はほとんど無いだろう。
</p>
  
<p>
  それでもせっかくなので解説しておこう。
  正しく理解できれば、「機械語も単なるバイト列で特別なことなんか何もない」という感覚が身に付けられるはずだ。
</p>

<p>
  まあよくわからなければ飛ばしてもらって構わない。リンカの説明を読む時に、知っていたほうがいい点もあるが、必須というほどでもないだろう。
</p>

<p>
  ここでは、x86_64 を使う。x86_64 の機械語は、現代に生き残っている機械語の中では最も複雑と言ってよくて、
  あんまり学習には向いてないのだが、筆者は身近なもので学習するのが一番だと思っているので、
  ここはあえて x86_64 を使っていこうと思う。
</p>

<p>
  x86_64 の機械語が理解できる頃には、他のCPUの機械語なんてクソ簡単に見えるようになっているはずだ。
</p>

<h3> シンプルなオペランド </h3>

<p> <a href="https://software.intel.com/en-us/articles/intel-sdm"> https://software.intel.com/en-us/articles/intel-sdm </a> に、Intel のマニュアルがあるので、それを開いてほしい。 </p>

<p> ここでまず見てほしいのは、volume 2D (2018/10 時点) の Appendix A だ。 </p>

<p>
  ここには、opcode table という表が書かれている。 
  opcode tableは、バイトと命令の対応を書いた表だ。
</p>

<p>
  <img src="opcode_table.png">
</p>

<p>
  <img src="opcode_table3.png">
</p>

<p> このふたつのテーブルは、命令バイト列の1byte目が、どの命令と対応するのかが書かれている。</p>

<p>
  オペランドを取る場合は、この先頭バイト列のあとに、オペランドを示すバイト列が続く。
  Grpと書かれている部分は、後続のバイト列によって命令が決まる。 
</p>

<p>
  x86 の 32bit と、x86_64 では、少し対応が変わって、命令の名前の横にi64と書かれいている命令は、x86_64では使えない。(読み方の詳細はマニュアルに書かれているのでそちらを参照してほしい)
</p>

<p>
  まずは、簡単なオペランドを取らない命令から見ていこう。
  オペランドを取らない命令で、1byte でよく使うのは、nop、ret などがある。
</p>

<p> <a href="x8664_machine_language/one_byte.s"> x8664_machine_language/one_byte.s </a> </p>

<pre>
	.globl main

main:
	nop
	ret
</pre>

<p>
  gcc に -c を付けてコンパイルしよう。これまで通り a.out まで作ってしまってもよいが、
  a.out は libc(TODO : libcの説明を書いてない) がリンクされていて、今は必要のない命令列が追加されてしまう。
</p>

<p> -c を付けてコンパイルすると、one_byte.o というファイルができるはずだ。objdump -d を使ってこれを逆アセンブルしよう。 </p>

<pre>
$ gcc -c one_byte.s
$ objdump  -d one_byte.o 

one_byte.o:     ファイル形式 elf64-x86-64


セクション .text の逆アセンブル:

0000000000000000 &lt;main&gt;:
   0:   90                      nop
   1:   c3                      retq   

</pre>

<p> nop が 0x90、ret が 0xc3 になっていて、opcode tableにもその対応が書かれていることを確認してほしい。</p>

<p>
  opcode table には、near RET(0xc3) と far RET(0xcb) が書かれているが、x86_64 のユーザプログラムでは、near RET だけ見ておけばよいのでこれの説明は省略する。
  オペランド付きのRET(0xc2, 0xca) は、Linuxでは使うことはないので、これも見なくてよい。
</p>

<p>
  次に即値をオペランドに取る命令だ。即値mov命令がこれに該当する。また、x86_64 では、RAX レジスタは他のレジスタより優遇されていて、算術命令のうち、rax をオペランド取る命令は、1byte命令になる。
</p>

<p> <a href="x8664_machine_language/one_byte_imm.s"> x8664_machine_language/one_byte_imm.s </a> </p>

<pre>
	.globl main

main:
	mov	$0x11223344, %eax
	mov	$0x11223344, %ecx
	add	$0x11223344, %eax
	sub	$0x11223344, %eax

	ret
</pre>

<p> これもobjdump -d で見てみよう </p>

<pre>
   0:   b8 44 33 22 11          mov    $0x11223344,%eax
   5:   b9 44 33 22 11          mov    $0x11223344,%ecx
   a:   05 44 33 22 11          add    $0x11223344,%eax
   f:   2d 44 33 22 11          sub    $0x11223344,%eax
  14:   c3                      retq   
</pre>

<p>
  1byte 命令のあとに、32bit即値が続くのが確認できる。
</p>

<p>
  ここでは、64bit レジスタではなく、32bit レジスタを使っている。
</p>

<p>
  x86_64 では、多くの命令は、8bit命令と32bit命令の二種類の命令が用意されている。
  16bit命令や64bit命令をを使う場合は、32bit 命令の前に<em>プレフィクス</em>を付ける。
</p>

<p> 
  16bit 命令を使うときは、命令の前に Operand size prefix(0x66) を付ける。
  64bit 命令を使うときは、命令の前に REX prefix を付けて、REX prefix 中の W ビットを 1にする。REX prefix については、あとで詳しく解説する。とりあえずここで使うのは、0x48 だ。
</p>

<p> <a href="x8664_machine_language/one_byte_imm_size.s"> x8664_machine_language/one_byte_imm_size.s </a> </p>

<pre>
	.globl main

main:
	mov	$0x11, %al    	# 8bit 命令は別のオペコードが割り当てられている
	mov	$0x1122, %ax	# 16bit 命令は0x66が付く
	mov	$0x11223344, %eax # 32bit 命令はプレフィクスが付かない
	mov	$0x1122334455667788, %rax # 64bit 命令は、REXプレフィクスが付く。この場合は0x48

	ret
</pre>

<pre>
   0:   b0 11                   mov    $0x11,%al
   2:   66 b8 22 11             mov    $0x1122,%ax
   6:   b8 44 33 22 11          mov    $0x11223344,%eax
   b:   48 b8 88 77 66 55 44    movabs $0x1122334455667788,%rax
  12:   33 22 11 
  15:   c3                      retq  
</pre>

<p> 8bit命令だけが、オペコードが 0xb0 になっていて、その他はオペコードは0xb8、16bitおよび64bit命令にはプレフィクスが付いていることを確認しよう</p>


<h3> ModR/M </h3>

<p>
  x86系命令セットの特徴として、多くの命令のオペランドにメモリを直接指定できるという点がある。
</p>

<p>
  説明を簡単にするために、ここまでは使ってこなかったが、add命令などは、レジスタを経由しなくともメモリ上の値を直接操作することができる。
</p>


<h3> REXプレフィクス </h3>

<p>
  x86_64は、32bit x86命令セットとそれなりの互換性を持たせながら、64bitに拡張し、レジスタ数も増やすという無茶なノルマを達成するために、
  REX プレフィクスというプレフィクスが増えた。
</p>

<h3> VEX, EVEX プレフィクス </h3>

<p> 書くと長くなるので各自で自習してください </p>

<p> <a href="index.html"> 戻る </a> </p>

</body>
</html>