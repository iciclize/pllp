<html>
<head>
  <meta charset="utf-8"/>
  <title> デバッガ </title>
  <link rel="stylesheet" type="text/css" href="../style.css">
  <script type="text/javascript" src="../js.js"></script>
</head>

<body onload="assign_section()">

<div id="global">

<p> <a href="../index.html"> 戻る </a> </p>


<div id="toc">
<p> 目次 </p>
</div>

<h1> デバッガ </h1>

<p>
  これまで何度も使ってきたgdb、つまりデバッガだが、これがどのように動いているかを見ていこう。
</p>

<p>
  "デバッガ" とはなんだろうか。
  "デバッガ" というと、バグを取ってくれるようなツールに聞こえるが、みなさんご存知のとおり、デバッガはプログラマのかわりにバグを取ってくれるわけではない。
  実際のデバッガの動作は実行中のプログラムの状態を見れるツール、つまり "プログラムの状態ビューワ" とでも言ったほうが、現実とあっているだろう。
</p>

<p>
  個人的には'デバッガ"という名称は実態とあってない、とは思うが、この章では、慣習にしたがって、プログラムの状態を調査、変更するツールのことを"デバッガ"と呼び、
  そのデバッガを使って実際に何かをすることを"デバッグ"と呼ぶ。
  また、デバッグされるプログラムの対象を"デバッギ(debugee)"と呼ぶ。
</p>

<p>
  この章では、まず、デバッガが必要とする基本的な操作について説明し、続けてデバッグ情報についても説明する。そのあと、その操作とデバッグ情報を組み合わせて、デバッガの機能を実現する方法について説明していく。
</p>

<h2> ptrace </h2>

<p>
  Linux ではデバッガの実装時に役立つ、ptrace というシステムコールがある。
</p>

<p>
  <em>ptrace</em> は、対象となるプロセスの状態を読み書きできるシステムコールである。
</p>

<p>
  デバッガを実装する場合、対象となるプログラムのメモリやレジスタを読み書きしたい場合が多い。
  ptrace を使えば、それが実現できる。
</p>

  
  <p><a href="ptrace1.c"> ptrace1.c </a><p>
<div class="pygments"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/ptrace.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">volatile</span> <span class="kt">uint64_t</span> <span class="n">x</span><span class="p">;</span>  <span class="cm">/* 他のプログラムから読み書きする変数はvolatileにする */</span>
    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 子プロセス(tracee) */</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mh">0xaa55aa55</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* 親プロセス(tracer) */</span>
        <span class="kt">int</span> <span class="n">st</span><span class="p">;</span>

        <span class="n">usleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_ATTACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* 子プロセスを監視対象(tracee)にする */</span>
        <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="cm">/* traceeが停止するまで待機 */</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="cm">/* traceeのメモリから値を取得 */</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="p">);</span>

        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* traceeを監視対象から外す */</span>

        <span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>  <span class="cm">/* 子プロセスの終了 */</span>
        <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

  
  <pre>
 $ gcc -Wall -no-pie -o ptrace1 ptrace1.c
 $ ./ptrace1</pre>
<pre>
aa55aa55
</pre>

  

<p>
  まず、PTRACE_ATTACHと対象プロセスのpidを引数にして、ptrace を呼び出す。これで、対象プロセスがアタッチされる(操作可能になる)。
  ptraceの説明では、操作する側のプロセス(ここでは親プロセス)を <em>tracer</em>、操作される側(ここでは子プロセス)を<em>tracee</em>
  と呼んでいる。それにならって、ここでは同じようにtracer,traceeと呼ぶことにしよう。
</p>

<p>
  tracer が tracee をアタッチすると、tracee は停止する。これは非同期に実行されるので、停止したのが確定するまでwaitpidで待つ。
</p>

<p>
  アタッチしたあと、PTRACE_PEEKDATAとpid,アドレスを引数にして、ptraceを呼び出すと、traceeのメモリからデータを読むことができる。
</p>

<p>
  この例では、tracee は、trace から fork したプロセスなので、変数 "x" のアドレスは同じになっている。そのため、PTRACE_PEEKDATA に x のアドレスを渡すと、traceeの変数"x"の値が取得できる。
  fork しない場合は、変数名とアドレスの対応は、なんらかの方法で取得する必要がある。取得方法についてはあとでデバッグ情報のところで解説しよう。
</p>

<p>
  tracerが必要な操作を終えたあとは、PTRACE_DETACHでデタッチする(操作を終了する)。traceeがアタッチされたままだと、シグナルがtracerに送られてしまい、挙動が変わってしまう。このプログラムはシグナルを使っていないので影響ないが、正しく処理するときはデタッチしておこう。
</p>


<p> tracee のメモリを書きかえたいときは、PTRACE_POKEDATA を使う。PTRACE_ATTACHで一時停止したプログラムは、PTRACE_CONT を使えば、再開できる。また、この例では使っていないが、再開したプログラムを再度一時停止したい場合は、SIGSTOPを止めたいスレッドに送る。 </p>


<p><a href="ptrace2.c"> ptrace2.c </a><p>
<div class="pygments"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/ptrace.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">volatile</span> <span class="kt">uint64_t</span> <span class="n">x</span><span class="p">;</span>  <span class="cm">/* 他のプログラムから読み書きする変数はvolatileにする */</span>
    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 子プロセス(tracee) */</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>  <span class="cm">/* tracerが書きかえてくれるまで待つ */</span>
            <span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* 親プロセス(tracer) */</span>
        <span class="kt">int</span> <span class="n">st</span><span class="p">;</span>

        <span class="n">usleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_ATTACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* 子プロセスを監視対象(tracee)にする */</span>
        <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="cm">/* traceeが停止するまで待機 */</span>

        <span class="kt">uint64_t</span> <span class="n">newdata</span> <span class="o">=</span> <span class="mh">0x88888888</span><span class="p">;</span>

        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">newdata</span><span class="p">);</span> <span class="cm">/* traceeのメモリへ書き込み */</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_CONT</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="cm">/* 停止したtraceeを再開 */</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* traceeを監視対象から外す */</span>

        <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="cm">/* 子プロセスの終了待ち */</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


  <pre>
 $ gcc -Wall -no-pie -o ptrace2 ptrace2.c
 $ ./ptrace2</pre>
<pre>
88888888
</pre>

  


<p> メモリと同様に、traceeのレジスタを読み書きすることができる。読むときはPTRACE_GETREGS、書くときはPTRACE_SETREGSを使う。</p>


<p><a href="ptrace3.c"> ptrace3.c </a><p>
<div class="pygments"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/ptrace.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/user.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 子プロセス(tracee) */</span>
        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
          <span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* 親プロセス(tracer) */</span>
        <span class="kt">int</span> <span class="n">st</span><span class="p">;</span>

        <span class="n">usleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_ATTACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* 子プロセスを監視対象(tracee)にする */</span>
        <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="cm">/* traceeが停止するまで待機 */</span>

        <span class="k">struct</span> <span class="nc">user_regs_struct</span> <span class="n">regs</span><span class="p">;</span>

        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>  <span class="cm">/* traceeのレジスタの値を取得 */</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;rip=%016llx, main=%016llx, delta=%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="p">.</span><span class="n">rip</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">main</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="p">.</span><span class="n">rip</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">main</span><span class="p">);</span>

        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* traceeを監視対象から外す */</span>

        <span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>
        <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<pre>
 $ gcc -Wall -no-pie -o ptrace3 ptrace3.c
 $ ./ptrace3</pre>
<pre>
rip=00000000004011c1, main=0000000000401186, delta=3b
</pre>



<p> プログラムカウンタが、main の近くにあることを確認しよう。 </p>

<h2> Linux 以外 (ptraceが無い場合) </h2>

<p> ここまでに、</p>

<ul>
  <li> プログラムを一時停止、再開する (実行状態の変更) </li>
  <li> メモリの読み書き </li>
  <li> レジスタの読み書き </li>
</ul>

<p>
  これらの操作について説明してきた。
  これらの操作は、デバッガを作るときの、一番基本となる操作である。
  デバッガには、色々な機能があるが、多くの機能が、この操作を使って実現されている。
  つまり、これらの操作ができれば、その上にデバッガを実装できるわけだ。
</p>

<p>
  Linux では、これらの操作を実現するために、ptraceというシステムコールを使っていた。POSIX互換のOSでは、ptraceが実装されていることが多く、OSX等でも同じようにこれらの操作ができる。では他のシステムではどうだろうか。
</p>

<h3> Windows </h3>

<p>
  Windowsでは、これらの操作と対応するAPIが用意されており、それを使えばこれらの操作を実現できる。
</p>

<table>
  <tr> <th> 操作 </th> <th> API </th> <th> 対応するLinuxでの操作 </th> </tr>

  <tr> <td> デバッグの開始 </td> <td> DebugActiveProcess </td> <td> ptrace(PTRACE_ATTACH) </td> </tr>
  <tr> <td> デバッグの終了 </td> <td> DebugActiveProcessStop </td> <td> ptrace(PTRACE_DETACH) </td> </tr>
  <tr> <td> 実行の一時停止 </td> <td> SuspendThread </td> <td> SIGSTOPを送る </td> </tr>
  <tr> <td> 実行の再開 </td> <td> ResumeThread </td> <td> ptrace(PTRACE_CONT) </td> </tr>
  <tr> <td> メモリからの読み込み </td> <td> ReadProcessMemory </td> <td> ptrace(PTRACE_PEEKDATA) </td> </tr>
  <tr> <td> メモリへの書き込み </td> <td> WriteProcessMemory </td> <td> ptrace(PTRACE_POKEDATA) </td> </tr>
  <tr> <td> レジスタからの読み込み </td> <td> GetThreadContext </td> <td> ptrace(PTRACE_PEEKUSER) </td> </tr>
  <tr> <td> レジスタへの書き込み </td> <td> SetThreadContext </td> <td> ptrace(PTRACE_POKEUSER) </td> </tr>
</table>


<h3> gdb stub(OSが無い場合) </h3>

<p> ではOSが無い場合はどうだろうか。 </p>

<p> OSが無い場合の対処方はいくつかあるが、gdb stub を使う方法を紹介しよう。 </p>

<p> <em>gdb stub</em> (GDBのマニュアルでは、<em>Remote Stub</em> と呼ばれている) というのは、デバッガからのコマンドを受けて、デバッガが必要とする操作を対象プログラムの中で実行するモジュールのことだ。 </p>

<p>
  実行中のプログラムは、自分が実行されている環境のメモリやレジスタの値を読み書きできる。これはつまり自分自身がデバッガの機能を実現するための一部になれるということである。
</p>

<div class="imgbox">
  <img src="gdbstub.svg" width="100%">
</div>

<p>
  gdb stub は、対象プログラムに埋め込まれて、外部のgdbからコマンドを待つ。gdbからはメモリを読み書きしろとか、レジスタを読み書きしろというコマンドが送られてくる。
  gdb stub は、そのコマンドに従って、プログラムの状態を読み書きし、その結果をgdbに返す。
</p>

<p> gdb のソースコードには、いくつかのCPU用のstubが付属している。例えば、i386用のstubは、 <a href="https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=gdb/stubs/i386-stub.c;h=04996b75cf68073a9bdc3baba92ad96419d567fd;hb=HEAD">https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=gdb/stubs/i386-stub.c;h=04996b75cf68073a9bdc3baba92ad96419d567fd;hb=HEAD</a> このようになっている。</p>

<p> 詳細な説明は省略するが、レジスタやメモリを読み書きできるように作ってあることを読み取ってほしい </p>

<h3> JTAG </h3>

<p> <em> JTAG </em> (Joint Test Action Group) とは、狭義にはハードウェアのテスト用の標準を定めるグループと、そのグループが決めた仕様のことである </p>

<p> 現代のCPUのような超高密度な集積回路は、外部から触れられるピンだけを使って、内部の状態を観測することが現実的ではない。 </p>

<p> そのため、集積度の高い回路では、内部に、テスト用の回路も作っておき、そのテスト用の回路を経由して、回路に問題がないかテストするという方法がとられることが多い。
<em>JTAG</em> は、このテスト用の回路をどうやって接続するか、というのを決めた仕様のことである。
</p>

</p>
…が、プログラマがJTAGと言った場合は、ほぼ確実に、<em>CPUに搭載されたデバッグ用のハードウェアを使ってデバッグするインターフェース、ツール類のこと</em>を指す。
プログラマが言う"JTAG"は、本来の意味と少し違ってしまっていることに注意してほしい。
</p>

<p>
  現代(と言ってもかなり昔からだが)のCPUは、その機能の一部に、CPUやメモリの状態を読み書きする「デバッグ用ハードウェア」が搭載されている。このハードウェアは、ほぼ確実にJTAG仕様に準拠した信号線を経由して、外部と繋がっている。そのため、この「デバッグ用のハードウェア」を使う場合は、JTAGケーブルを使って、プログラムの状態を観測することになる。
</p>

<p>
  この、「JTAG経由で繋がったデバッグ用のハードウェアを使ってgdbなどのデバッガを動かす」というのが、省略されて、「JTAGデバッグ」、そして、その周辺ツールが「JTAG」と呼ばれるようになっている。(筆者は、この用語の使いかたはWikipediaをWikiと略すよりひどいのではないかと思う。データの経路が名前になっているから、Wikipediaをインターネットと呼ぶようなものである)
</p>

<p>
  「デバッグ用のハードウェア」は、ptraceやgdb stubとほぼ同じように、プログラムの実行状態の制御、メモリ・レジスタの読み書きができる。
</p>

<p>
  デバッグ用のハードウェアは、CPUの状態とは独立して動くので、ソフトウェアが完全に壊れて何も動かない場合や、ソフトウェアが初期化されていない状態でも使える。
  gdb stub を動かすには、割り込みなどが正しく処理されている必要があり、割り込みが動かないような問題をデバッグしたい場合や、割り込み等を初期化する前の状態をデバッグしたい場合には使えない。そのような場合でも、JTAG経由なら、デバッグできる場合が多いのは、助かる場面が多いだろう。
</p>

<p>
  JTAG経由でデバッガを使う場合は、実装方法は色々あるが、一例として接続サーバー経由でgdbを使う方法を説明しておこう。
</p>

<p>
  gdb stubのところで簡単に説明したが、gdbは、gdb stubに送るコマンドを、ネットワーク経由でも送れるようになっている。
  JTAG用に実装された接続サーバーは、gdb stubと同様に、gdbから送られるコマンドをパースして、それをハードウェア依存のコマンドに変換してJTAG経由でそのコマンドを状態観測用ハードウェアに送る。ハードウェアから得られた情報は、gdb stubと同様に、ネットワーク経由でgdbに届けられる。
  (接続サーバーが、gdb stubのように動作する)
</p>

<div class="imgbox">
  <img src="jtagdebug.svg" width="100%">
</div>


<h3> ICE (特に小さなCPUを使う場合) </h3>

<p> 組み込み開発でも、特に小さなCPUを使う場合は、<em> ICE </em> (In-circuit Emulator)というものを使うことがある。 </p>

<p>
  ICE は、状態観測用のインターフェースを付けた、デバッガに接続するためのCPUだ。
</p>

<p>
  JTAGが、CPUの機能の一部として実装されているのに対し、ICE は、チップ全体がデバッグ用に作られている。
</p>

<p>
  色々な周辺機器が繋がったSoCの場合、JTAG 経由では、CPUのコアしか状態観測ができず、I/Oの状態はCPUから見た状態しか観測できないが、ICE では、周辺I/Oも含めて、状態を監視、変更することができる。
</p>

<p>
  例えば、ダイマデバイスなどは、JTAG経由ではCPUを停止しても動き続けるが、ICE で状態を停止すると、タイマとCPUコアを同時に停止でき、問題が発生したときのタイマの状態を正しく観測できる。
</p>

<p>
  ただ、これが実現できるのは、CPUが本当に小さい場合だけで、大きなCPUでは、デバッグ専用のハードウェアを作るのは現実的ではない。現在では、組み込み開発でも本物のICEを見ることはほとんどなくなってしまったのではないかと思う。(筆者も数回ぐらいしか使ったことがない)
</p>


<h2> デバッガの実装 </h2>

<p> ここまでで、CPUやメモリの状態を観測する基本的な方法を説明した。ここからは、その方法を使ってどのようにデバッガを作っていくかを説明しよう。 </p>

<h3> デバッグ情報 </h3>

<p>
  デバッガの機能で興味深いのは、<em>変数や関数が存在するかのように見える</em> 点ではないだろうか。
</p>


<p><a href="print-a.c"> print-a.c </a><p>
<div class="pygments"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">int_value</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">str_value</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello World&quot;</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;int_value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">int_value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<pre>
 $ gcc -no-pie -g -Wall -o print-a print-a.c
</pre>

<pre>
 $ gdb --args ./print-a
Reading symbols from ./print-a...

(gdb) <span class="gdb-command">start
</span>Temporary breakpoint 1 at 0x40112a: file print-a.c, line 6.
Starting program: /home/tanakmura/src/pllp/docs/debugger/print-a 

Temporary breakpoint 1, main () at print-a.c:6
6	  printf(&quot;int_value = %d\n&quot;, int_value);
(gdb) <span class="gdb-command">print int_value
</span>$1 = 99
(gdb) <span class="gdb-command">print str_value
</span>$2 = &quot;Hello World&quot;
(gdb) <span class="gdb-command">set int_value=123456
</span>(gdb) <span class="gdb-command">continue
</span>Continuing.
int_value = 123456
[Inferior 1 (process 170004) exited normally]
</pre>


<pre>
(gdb) <span class="gdb-command">print int_value # 変数名 "int_value" が使える</span>
</pre>

<p>
  gdb が、変数 "int_value","str_value" という変数の名前をそのまま使えていることを確認してほしい。
  さらに、変数の型に応じて、適切な表示方法を採用しているのも確認してほしい。
  int型の変数に対しては、数字を表示し、char[]型の変数に対しては、文字列を表示している。
</p>

<p>
  CPUが実行する時に使うデータは、メモリ上に展開されたバイナリデータだけで、操作するデータの変数名や型などは、実行時には必要ではない。
  ところが、デバッガからプログラムを実行すると、そこに変数名や型が存在するかのようにプログラムの状態を操作できるのだ。これはどうやって実現しているのだろうか。
</p>

<p>
  これを実現するために、コンパイラやリンカは、実行ファイルの出力時に、<em>デバッグ情報</em>と呼ばれる、デバッガを補助するための追加のデータを、実行ファイルに含めて出力する。(Visual Studio のコンパイラでは、実行ファイルとは別に出力される)
</p>

<pre>
 $ gcc -no-pie -g -Wall -o print-a print-a.c
</pre>



<p> ここでは、コンパイル時に <em>-g</em> を付けている点に注意してほしい。この <em>-g</em> は、デバッグ情報を生成するようにgccに指示するオプションだ。これを付けると、gccとリンカは、出力される実行ファイルにデバッグ情報を追加する。</p>

<p> デバッグ情報の中身を見てみよう。デバッグ情報は readelf に -w オプションを付けるか、objdump に -g オプションを付けると見ることができる。どちらも同じものが表示されるので、以下では readelf -w を使うことにする。 </p>

<pre>
 $ readelf -w print-a
Contents of the .eh_frame section:


00000000 0000000000000014 00000000 CIE
  Version:               1
  Augmentation:          "zR"
  Code alignment factor: 1
  Data alignment factor: -8
  Return address column: 16
  Augmentation data:     1b
  DW_CFA_def_cfa: r7 (rsp) ofs 8
  DW_CFA_offset: r16 (rip) at cfa-8
  DW_CFA_nop
  DW_CFA_nop

... (以下大量の出力) ...
</pre>

<p> たった8行のプログラムにしては、かなりの量の情報がある。ここには一体何が含まれているのだろうか。以下では、このデバッグ情報の中身について説明していこう。 </p>

<h4> シンボルからアドレスと型情報への変換 </h4>

<p>
  デバッグ情報には、どういう情報を含めておけばよいだろうか。まず、print-a の例で説明したような、
</p>

<pre>
 (gdb) print int_value
 (gdb) set int_value=123456
</pre>

<p>
  といったようなコマンドを実現するためには、
</p>

<ul>
  <li> シンボル名から機械語中の実行時のアドレスを取得する </li>
  <li> シンボル名から型情報を取得する </li>
</ul>

<p>
  という処理が必要だ。これらの処理ができれば、gdb の print は、
</p>

<ol>
  <li> int_value という名前から、型情報とアドレスを取得する </li>
  <li> ptrace を使って、変数のアドレスから型のサイズ分バイト列を取得する </li>
  <li> 取得したバイト列を型情報に従って表示する </li>
</ol>

<p>
  という手順で実現できる。
</p>

<p>
  では、シンボル名からアドレスや型情報を取得するデータとはどのようなものだろうか。
</p>

<p>
  次のようなプログラムを考えよう。
</p>


<p><a href="dummy-debuginfo.c"> dummy-debuginfo.c </a><p>
<div class="pygments"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="k">enum</span> <span class="n">var_type</span> <span class="p">{</span>
    <span class="n">TYPE_INT</span><span class="p">,</span>
    <span class="n">TYPE_CHAR_ARRAY</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">type_to_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">var_type</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">TYPE_INT</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&quot;int&quot;</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">TYPE_CHAR_ARRAY</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&quot;char[]&quot;</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="k">return</span> <span class="s">&quot;unknown type&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">VarDebugInfo</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">;</span>
    <span class="k">enum</span> <span class="n">var_type</span> <span class="n">type</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">var_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* デバッグ情報のようなもの */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">VarDebugInfo</span> <span class="n">dummy_debuginfo</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;int_value&quot;</span><span class="p">,</span> <span class="n">TYPE_INT</span><span class="p">,</span> <span class="mh">0x8000</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;str_value&quot;</span><span class="p">,</span> <span class="n">TYPE_CHAR_ARRAY</span><span class="p">,</span> <span class="mh">0x8008</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>                              <span class="cm">/* 終端 */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">VarDebugInfo</span> <span class="o">*</span>
<span class="n">extract_var_debug_info</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dummy_debuginfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">symbol</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;cannot find debug info for &#39;%s&#39;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">symbol</span><span class="p">);</span>
            <span class="n">abort</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dummy_debuginfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">symbol</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">dummy_debuginfo</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;usage : %s &lt;symbol&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="k">struct</span> <span class="nc">VarDebugInfo</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">extract_var_debug_info</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sym: %s, type:%s, addr=0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
           <span class="n">info</span><span class="o">-&gt;</span><span class="n">symbol</span><span class="p">,</span>
           <span class="n">type_to_str</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span>
           <span class="n">info</span><span class="o">-&gt;</span><span class="n">var_addr</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>
  これは、以下のテーブルから、文字列と関連付けられた情報を取得するプログラムだ。
</p>

<pre>
/* デバッグ情報のようなもの */
const struct VarDebugInfo dummy_debuginfo[] = {
    {"int_value", TYPE_INT, 0x8000},
    {"str_value", TYPE_CHAR_ARRAY, 0x8008},
    {NULL}                              /* 終端 */
};
</pre>


<p>
ここでは、テーブルに入っている値は意味のない値だが、とりあえず何か名前を指定すると、その名前と関連する情報が表示される点を確認してほしい。
</p>

<pre>
 $ gcc  -o dummy-debuginfo dummy-debuginfo.c
</pre>

<pre>
 $ ./dummy-debuginfo int_value 
sym: int_value, type:int, addr=0x0000000000008000 <em> # "int_value" という文字列と関連する情報が表示される </em>

 $ ./dummy-debuginfo str_value 
sym: str_value, type:char[], addr=0x0000000000008008 <em> # "str_value" という文字列と関連する情報が表示される </em>

</pre>



<p>
  では、この dummy_debuginfo に意味のある値が入っていたらどうなるだろうか。
</p>

<p> 次のプログラムをコンパイルしたのち、readelf -s を使って、int_value, str_value のアドレスを取得しよう。
  (実行ファイルを簡単にするため、libcとスタートアップルーチンをリンクしていない。これの意味については<a href="../linker.html">リンカの章</a>を参照のこと)
 </p>


<p><a href="debuggee1.c"> debuggee1.c </a><p>
<div class="pygments"><pre><span></span><span class="kt">int</span> <span class="n">int_value</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">str_value</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello World&quot;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">_start</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">int_value</span> <span class="o">=</span> <span class="mi">9999</span><span class="p">;</span>
  <span class="n">str_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;@&#39;</span><span class="p">;</span>

  <span class="k">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot; &quot;</span>  <span class="o">:::</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>  <span class="cm">/* メモリへ必ず書き込むようにする */</span>

  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">;</span>
<span class="p">}</span>
</pre></div>

<pre>
 $ gcc -no-pie -g -nostartfiles -nostdlib -o debuggee1 debuggee1.c
</pre>

<pre>
 $ readelf -s debuggee1 

Symbol table &#x27;.symtab&#x27; contains 10 entries:
  番号:      値         サイズ タイプ  Bind   Vis      索引名
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS debuggee1.c
     2: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS 
     3: 0000000000402000     0 NOTYPE  LOCAL  DEFAULT    4 __GNU_EH_FRAME_HDR
     4: 0000000000404008    12 OBJECT  GLOBAL DEFAULT    6 str_value
     5: 0000000000404000     4 OBJECT  GLOBAL DEFAULT    6 int_value
     6: 0000000000401000    23 FUNC    GLOBAL DEFAULT    3 _start
     7: 0000000000404014     0 NOTYPE  GLOBAL DEFAULT    6 __bss_start
     8: 0000000000404014     0 NOTYPE  GLOBAL DEFAULT    6 _edata
     9: 0000000000404018     0 NOTYPE  GLOBAL DEFAULT    6 _end

</pre>


<pre>
 $ readelf -s debugee1 | grep int_value | awk '{print $2}' # 変数 int_value のアドレス
0000000000404000
 $ readelf -s debugee1 | grep str_value | awk '{print $2}' # 変数 str_value のアドレス
0000000000404008
</pre>



<p> この取得したアドレスをさきほどのプログラムに入れたらどうなるだろうか。 </p>
<pre>
/* debugee1.c のデバッグ情報 */
const struct VarDebugInfo debuginfo_for_debugee1[] = {
    {"int_value", TYPE_INT, 0x404000},
    {"str_value", TYPE_CHAR_PTR, 0x404008},
    {NULL}                              /* 終端 */
};
</pre>

<p> これは、もはやダミーの情報ではなく、debugee1 というプログラムのためのデバッグ情報になるのだ。 </p>

<p> このテーブルを使って、gdb の print のような機能を実装してみよう。 </p>


<p><a href="debugger1.c"> debugger1.c </a><p>
<div class="pygments"><pre><span></span><span class="cm">/* gdb の print のような機能を実現するプログラム */</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/ptrace.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="k">enum</span> <span class="n">var_type</span> <span class="p">{</span>
    <span class="n">TYPE_INT</span><span class="p">,</span>
    <span class="n">TYPE_CHAR_ARRAY</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">VarDebugInfo</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">;</span>
    <span class="k">enum</span> <span class="n">var_type</span> <span class="n">type</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">var_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* debuggee1.c のデバッグ情報 */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">VarDebugInfo</span> <span class="n">debuginfo_for_debuggee1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/* var_addr には readelf -s で取得したアドレスを入れる */</span>
    <span class="p">{</span><span class="s">&quot;int_value&quot;</span><span class="p">,</span> <span class="n">TYPE_INT</span><span class="p">,</span> <span class="mh">0x404000</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;str_value&quot;</span><span class="p">,</span> <span class="n">TYPE_CHAR_ARRAY</span><span class="p">,</span> <span class="mh">0x404008</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>                              <span class="cm">/* 終端 */</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">VarDebugInfo</span> <span class="o">*</span>
<span class="n">extract_var_debug_info</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">debuginfo_for_debuggee1</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">symbol</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;cannot find debug info for &#39;%s&#39;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">symbol</span><span class="p">);</span>
            <span class="n">abort</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">debuginfo_for_debuggee1</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">symbol</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">debuginfo_for_debuggee1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">print_var_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">VarDebugInfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">TYPE_INT</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s:%d, addr=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">symbol</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var_addr</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">TYPE_CHAR_ARRAY</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">uint8_t</span> <span class="n">v8</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var_addr</span><span class="o">+</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v8</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v8</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s:%s, var_addr=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">symbol</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var_addr</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">&quot;xx&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;usage : %s &lt;symbol&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">access</span><span class="p">(</span><span class="s">&quot;./debuggee1&quot;</span><span class="p">,</span> <span class="n">X_OK</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;cannot find program `debuggee1` (please compile debuggee1.c)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">pid</span><span class="o">=</span><span class="n">fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;./debuggee1&quot;</span><span class="p">,</span><span class="nb">NULL</span><span class="p">};</span>
        <span class="n">execve</span><span class="p">(</span><span class="s">&quot;./debuggee1&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">st</span><span class="p">;</span>
        <span class="n">usleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_ATTACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">&quot;ptrace&quot;</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">const</span> <span class="k">struct</span> <span class="nc">VarDebugInfo</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">extract_var_debug_info</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

        <span class="n">print_var_info</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

        <span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<pre>
 $ gcc  -o debugger1 debugger1.c
</pre>

<pre>
 $ ./debugger1 int_value 
int_value:9999, addr=404000

</pre>

<pre>
 $ ./debugger1 str_value 
str_value:@ello World, var_addr=404008

</pre>



<p>
  このプログラムを実行して、
</p>

<ul>
  <li> 引数に int_value を指定した場合は、対象プログラム debugee1 の変数int_valueの値が整数値として表示される</li>
  <li> 引数に str_value を指定した場合は、変数str_valueの値が文字列として表示される </li>
</ul>

<p> の二点を確認し、debuginfo_for_debugee1というテーブルが、gdb の print コマンドのようなものを実行するのに必要な情報として機能していることを確認してほしい。 </p>

<p>
  このテーブルは、<em> シンボル名をキーにして、そのシンボルと関連する情報を取得できる </em> データとなっている。
</p>

<p>
  実際のデバッグ情報も、同じように、シンボルをキーにして、そのシンボルと関連する情報を取得できる構造になっている、つまり、このdebuginfo_for_debugee1と同じような構造になっているわけだ。
</p>

<p>
  さきほどと同じように、readelf -w でデバッグ情報を見ていく。readelf -w は、デバッグ情報と関連するセクションを全て表示するが、表示するセクションを選ぶこともできる。
  readelf -wi を使って、.debug_info セクションのみを表示してみよう。
</p>


<pre>
 $ readelf -wi debuggee1 
.debug_info セクションの内容:

  コンパイル単位 @ オフセット 0x0:
   長さ:        0x98 (32-bit)
   バージョン:    5
   Unit Type:     DW_UT_compile (1)
   省略オフセット: 0x0
   ポインタサイズ:8
 &lt;0&gt;&lt;c&gt;: 省略番号: 3 (DW_TAG_compile_unit)
    &lt;d&gt;   DW_AT_producer    : (間接文字列、オフセット: 0x7): GNU C17 11.1.0 -mtune=generic -march=x86-64 -g
    &lt;11&gt;   DW_AT_language    : 29	(C11)
    &lt;12&gt;   DW_AT_name        : (間接行文字列、オフセット: 0x27): debuggee1.c
    &lt;16&gt;   DW_AT_comp_dir    : (間接行文字列、オフセット: 0x0): /home/tanakmura/src/pllp/docs/debugger
    &lt;1a&gt;   DW_AT_low_pc      : 0x401000
    &lt;22&gt;   DW_AT_high_pc     : 0x17
    &lt;2a&gt;   DW_AT_stmt_list   : 0x0
 &lt;1&gt;&lt;2e&gt;: 省略番号: 1 (DW_TAG_variable)
    &lt;2f&gt;   DW_AT_name        : (間接文字列、オフセット: 0x52): int_value
    &lt;33&gt;   DW_AT_decl_file   : 1
    &lt;33&gt;   DW_AT_decl_line   : 1
    &lt;34&gt;   DW_AT_decl_column : 5
    &lt;35&gt;   DW_AT_type        : &lt;0x43&gt;
    &lt;39&gt;   DW_AT_external    : 1
    &lt;39&gt;   DW_AT_location    : 9 byte block: 3 0 40 40 0 0 0 0 0 	(DW_OP_addr: 404000)
 &lt;1&gt;&lt;43&gt;: 省略番号: 4 (DW_TAG_base_type)
    &lt;44&gt;   DW_AT_byte_size   : 4
    &lt;45&gt;   DW_AT_encoding    : 5	(signed)
    &lt;46&gt;   DW_AT_name        : int
 &lt;1&gt;&lt;4a&gt;: 省略番号: 5 (DW_TAG_array_type)
    &lt;4b&gt;   DW_AT_type        : &lt;0x61&gt;
    &lt;4f&gt;   DW_AT_sibling     : &lt;0x5a&gt;
 &lt;2&gt;&lt;53&gt;: 省略番号: 6 (DW_TAG_subrange_type)
    &lt;54&gt;   DW_AT_type        : &lt;0x5a&gt;
    &lt;58&gt;   DW_AT_upper_bound : 11
 &lt;2&gt;&lt;59&gt;: Abbrev Number: 0
 &lt;1&gt;&lt;5a&gt;: 省略番号: 2 (DW_TAG_base_type)
    &lt;5b&gt;   DW_AT_byte_size   : 8
    &lt;5c&gt;   DW_AT_encoding    : 7	(unsigned)
    &lt;5d&gt;   DW_AT_name        : (間接文字列、オフセット: 0x40): long unsigned int
 &lt;1&gt;&lt;61&gt;: 省略番号: 2 (DW_TAG_base_type)
    &lt;62&gt;   DW_AT_byte_size   : 1
    &lt;63&gt;   DW_AT_encoding    : 6	(signed char)
    &lt;64&gt;   DW_AT_name        : (間接文字列、オフセット: 0x5c): char
 &lt;1&gt;&lt;68&gt;: 省略番号: 1 (DW_TAG_variable)
    &lt;69&gt;   DW_AT_name        : (間接文字列、オフセット: 0x36): str_value
    &lt;6d&gt;   DW_AT_decl_file   : 1
    &lt;6d&gt;   DW_AT_decl_line   : 2
    &lt;6e&gt;   DW_AT_decl_column : 6
    &lt;6f&gt;   DW_AT_type        : &lt;0x4a&gt;
    &lt;73&gt;   DW_AT_external    : 1
    &lt;73&gt;   DW_AT_location    : 9 byte block: 3 8 40 40 0 0 0 0 0 	(DW_OP_addr: 404008)
 &lt;1&gt;&lt;7d&gt;: 省略番号: 7 (DW_TAG_subprogram)
    &lt;7e&gt;   DW_AT_external    : 1
    &lt;7e&gt;   DW_AT_name        : (間接文字列、オフセット: 0x0): _start
    &lt;82&gt;   DW_AT_decl_file   : 1
    &lt;83&gt;   DW_AT_decl_line   : 4
    &lt;84&gt;   DW_AT_decl_column : 5
    &lt;85&gt;   DW_AT_type        : &lt;0x43&gt;
    &lt;89&gt;   DW_AT_low_pc      : 0x401000
    &lt;91&gt;   DW_AT_high_pc     : 0x17
    &lt;99&gt;   DW_AT_frame_base  : 1 byte block: 9c 	(DW_OP_call_frame_cfa)
    &lt;9b&gt;   DW_AT_call_all_calls: 1
 &lt;1&gt;&lt;9b&gt;: Abbrev Number: 0


</pre>


<p> 次の箇所に注目しよう </p>

<pre>
 &lt;1&gt;&lt;2e&gt;: 省略番号: 1 (DW_TAG_variable)
    &lt;2f&gt;   DW_AT_name        : (間接文字列、オフセット: 0x52): int_value  <em> # シンボル名int_value </em>
    &lt;33&gt;   DW_AT_decl_file   : 1
    &lt;33&gt;   DW_AT_decl_line   : 1
    &lt;34&gt;   DW_AT_decl_column : 5
    &lt;35&gt;   DW_AT_type        : &lt;0x43&gt; <em> # この0x43が下の &lt;43&gt; と対応していて、signed int を意味する </em>
    &lt;39&gt;   DW_AT_external    : 1
    &lt;39&gt;   DW_AT_location    : 9 byte block: 3 0 40 40 0 0 0 0 0 	(DW_OP_addr: 404000) <em> # int_valueのアドレスは0x404000 </em>
 &lt;1&gt;&lt;43&gt;: 省略番号: 4 (DW_TAG_base_type) <em> # signed int </em>
    &lt;44&gt;   DW_AT_byte_size   : 4
    &lt;45&gt;   DW_AT_encoding    : 5	(signed)
    &lt;46&gt;   DW_AT_name        : int

(.. 省略 ..)

 &lt;1&gt;&lt;4a&gt;: 省略番号: 5 (DW_TAG_array_type) <em> # char [] 型 </em>
    &lt;4b&gt;   DW_AT_type        : &lt;0x61&gt; <em> # 下の&lt;61&gt;と対応していて、char型を意味する </em>
    &lt;4f&gt;   DW_AT_sibling     : &lt;0x5a&gt;

(.. 省略 ..)

 &lt;1&gt;&lt;61&gt;: 省略番号: 2 (DW_TAG_base_type) <em> # char 型 </em>
    &lt;62&gt;   DW_AT_byte_size   : 1
    &lt;63&gt;   DW_AT_encoding    : 6	(signed char)
    &lt;64&gt;   DW_AT_name        : (間接文字列、オフセット: 0x5c): char

(.. 省略 ..)

 &lt;1&gt;&lt;68&gt;: 省略番号: 1 (DW_TAG_variable)
    &lt;69&gt;   DW_AT_name        : (間接文字列、オフセット: 0x36): str_value <em> # シンボル名str_value </em>
    &lt;6d&gt;   DW_AT_decl_file   : 1
    &lt;6d&gt;   DW_AT_decl_line   : 2
    &lt;6e&gt;   DW_AT_decl_column : 6
    &lt;6f&gt;   DW_AT_type        : &lt;0x4a&gt; <em> # 上の &lt;4a&gt; 対応して char[] を意味する </em>
    &lt;73&gt;   DW_AT_external    : 1
    &lt;73&gt;   DW_AT_location    : 9 byte block: 3 8 40 40 0 0 0 0 0 	(DW_OP_addr: 404008) <em> # str_valueのアドレスは0x404008 </em>
</pre>

<p> この情報は、さきほど作った </p>

<pre>
/* debugee1.c のデバッグ情報 */
const struct VarDebugInfo debuginfo_for_debugee1[] = {
    {"int_value", TYPE_INT, 0x404000},
    {"str_value", TYPE_CHAR_ARRAY, 0x404008},
    {NULL}                              /* 終端 */
};
</pre>

<p>
  このテーブルとかなり似たデータが含まれている。つまり、この.debug_info セクションを適切に読むことができれば、
  上で見たdebuggee1.c のプログラムと同じように <em> シンボル名をキーにして、そのシンボルと関連する情報を取得 </em> できるわけだ。
</p>

<div class="imgbox">
  <img src="sym_to_info.svg" width="100%">
</div>


<p>
  この.debug_infoに含まれる情報は、<em>DWARF (debugging with attributed record formats)</em>という仕様に従って、格納されている。
  DWARFの構造は、少し複雑なので、ひととおりデバッグ情報について説明したあとで解説しよう。
  しばらくは readelf -w の情報を参考に、読み進めていってほしい。
</p>

<!--
<p>
  それでは、実際に、この .debug_info セクションから、VarDebugInfo のテーブルを作るプログラムを書いてみよう。
  このプログラムは、ELFファイルを操作する処理が含まれている。ELFファイルを操作するために知っておく構造については、リンカの章で説明しているので、そちらも参照してほしい。<span class="kokomade"> (まだ書いてないです。そのうち書きます) </span>
</p>
-->

<h4> アドレスからシンボル情報への変換 </h4>

<p>
  ここまでで、デバッグ情報を使えば、シンボルからそのアドレスや型情報などが取得できることを説明した。
  それとは別に、デバッグ情報を使えば、<em>アドレスからそのアドレスに関する情報を取得する</em> こともできる。
</p>


<pre>
 $ gdb --args ./debuggee1
Reading symbols from ./debuggee1...

(gdb) <span class="gdb-command">b _start
</span>Breakpoint 1 at 0x401004: file debuggee1.c, line 5.
(gdb) <span class="gdb-command">run
</span>Starting program: /home/tanakmura/src/pllp/docs/debugger/debuggee1 

Breakpoint 1, _start () at debuggee1.c:5
5	  int_value = 9999;
(gdb) <span class="gdb-command">print &amp;str_value
</span>$1 = (char (*)[12]) 0x404008 &lt;str_value&gt;
(gdb) <span class="gdb-command">print (char*)0x404008
</span>$2 = 0x404008 &lt;str_value&gt; &quot;Hello World&quot;<span class="gdb-command-comment"><span class="gdb-command-comment"> # 0x404008 = str_value だと表示される </span></span>
</pre>



<p> 0x404008 のアドレスにある値を表示しようとすると、そこは &lt;str_value&gt; だと表示されている点を確認してほしい。 </p>

<p> デバッグ情報には、シンボルとアドレスの対応が含まれているので、これはデバッグ情報の読みかたを変えるだけで実現できる。 </p>


<pre>
 $ gcc  -o dummy-debuginfo2 dummy-debuginfo2.c
</pre>

<pre>
 $ ./dummy-debuginfo2 0x404000 
sym: int_value, type:int, addr=0x0000000000404000

</pre>

<pre>
 $ ./dummy-debuginfo2 0x404008 
sym: str_value, type:char[], addr=0x0000000000404008

</pre>



<p>
  シンボルとアドレスの対応を含む情報があれば、アドレスの数値から、シンボルに関する情報を取得できることを確認しよう。
</p>

<div class="imgbox">
  <img src="addr_to_info.svg" width="100%">
</div>



<h4> アドレスからソース位置への変換 </h4>

<p> デバッグ時には、 <em>プログラムカウンタの値からファイル名・行番号を取得</em>できていることに注目してほしい。</p>



<p><a href="debuggee2.c"> debuggee2.c </a><p>
<div class="pygments"><pre><span></span><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">_start</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">++</span><span class="p">;</span>

    <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                       <span class="cm">/* アドレス0にアクセス、エラーを起こして停止させる */</span>

    <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<pre>
 $ gcc -no-pie -g -nostartfiles -nostdlib -o debuggee2 debuggee2.c
</pre>

<pre>
 $ gdb --args ./debuggee2
Reading symbols from ./debuggee2...

(gdb) <span class="gdb-command">run
</span>Starting program: /home/tanakmura/src/pllp/docs/debugger/debuggee2 

Program received signal SIGSEGV, Segmentation fault.
_start () at debuggee2.c:5
5	    *(int*)0 = 0;                       /* アドレス0にアクセス、エラーを起こして停止させる */
(gdb) <span class="gdb-command">disassemble
</span>Dump of assembler code for function _start:
   0x0000000000401000 &lt;+0&gt;:	push   %rbp
   0x0000000000401001 &lt;+1&gt;:	mov    %rsp,%rbp
   0x0000000000401004 &lt;+4&gt;:	mov    0x2ff6(%rip),%eax        # 0x404000 &lt;a&gt;
   0x000000000040100a &lt;+10&gt;:	add    $0x1,%eax
   0x000000000040100d &lt;+13&gt;:	mov    %eax,0x2fed(%rip)        # 0x404000 &lt;a&gt;
   0x0000000000401013 &lt;+19&gt;:	mov    $0x0,%eax
=&gt; 0x0000000000401018 &lt;+24&gt;:	movl   $0x0,(%rax)
   0x000000000040101e &lt;+30&gt;:	mov    $0xa,%eax
   0x0000000000401023 &lt;+35&gt;:	pop    %rbp
   0x0000000000401024 &lt;+36&gt;:	ret    
End of assembler dump.
</pre>




<pre>
Program received signal SIGSEGV, Segmentation fault.
_start () at debuggee2.c:5                      <em> # debugee2.c の 5行目 ということがわかる </em>
5	    *(int*)0 = 0;                       /* アドレス0にアクセス、エラーを起こして停止させる */
</pre>

<p> エラーが発生している箇所とソースコードの対応がとれていることを確認しよう。 </p>

<p> (アドレス0にアクセスすると、エラーが発生し、止まる理由と、そのときのプログラムカウンタが取得できる理由については、OSのところで解説する <span class="kokomade">注意:まだ書いてない</span>。ここでは、アドレス0にアクセスすると停止して、そのときのプログラムカウンタの位置がわかることだけ見ておいてほしい) </p>

<p>
  これは、さきほどと同じように、アドレスと関連する情報を結び付けて保存してあるデバッグ情報を応用すれば実現できる。
  さきほどの例では、変数のアドレスと、そのシンボル名、型情報が関連付けられて保存されていた。
  この場合は、<em>機械語アドレスとソースコードの位置の対応</em>が保存されている。
</p>

<div class="imgbox">
  <img src="addr_to_loc.svg" width="100%">
</div>

<p>
  ここで、全ての機械語の命令ごとに、ファイル名と行番号の全てを保存すると、膨大な量になってしまう点に注意しよう。
  機械語は一命令数バイトだが、ファイル名は、文字数分のバイト数が必要で、直接保存すると、命令サイズに対して、デバッグ情報のサイズが数十倍になってしまう可能性がある。
  これを回避するため、ソースコード位置の情報は、実際のデバッグ情報では、直前の機械語との差分のみを保存する専用のフォーマットになっている。
</p>

<p> この、ソースコード位置に関連するデバッグ情報を表示するには、readelf -wl を使う。 </p>

<pre>
 $ readelf -wl debuggee2 
セクション .debug_line のデバッグ内容の生ダンプ:

  オフセット:                  0x0
  長さ:                        84
  DWARF バージョン:            5
  Address size (bytes):        8
  Segment selector (bytes):    0
  Prologue の長さ:             42
  最小命令長:                  1
  命令ごとの最大操作数:        1
  &#x27;is_stmt&#x27; の初期値:          1
  Line ベース:                 -5
  Line 範囲:                   14
  オペコードベース:            13

 オペコード:
  オペコード 1 は 0 個の引数を持ちます
  オペコード 2 は 1 個の引数を持ちます
  オペコード 3 は 1 個の引数を持ちます
  オペコード 4 は 1 個の引数を持ちます
  オペコード 5 は 1 個の引数を持ちます
  オペコード 6 は 0 個の引数を持ちます
  オペコード 7 は 0 個の引数を持ちます
  オペコード 8 は 0 個の引数を持ちます
  オペコード 9 は 1 個の引数を持ちます
  オペコード 10 は 0 個の引数を持ちます
  オペコード 11 は 0 個の引数を持ちます
  オペコード 12 は 1 個の引数を持ちます

 The Directory Table (offset 0x22, lines 1, columns 1):
  エントリー	名前
  0	(間接行文字列、オフセット: 0x0): /home/tanakmura/src/pllp/docs/debugger

 The File Name Table (offset 0x2c, lines 2, columns 2):
  エントリー	Dir	名前
  0	0	(間接行文字列、オフセット: 0x27): debuggee2.c
  1	0	(間接行文字列、オフセット: 0x27): debuggee2.c

 Line Number Statements:
  [0x00000036]  列幅を 14 に設定します
  [0x00000038]  拡張命令コード 2: 設定アドレス 0x401000
  [0x00000043]  Special opcode 6: advance Address by 0 to 0x401000 and Line by 1 to 2
  [0x00000044]  列幅を 6 に設定します
  [0x00000046]  Special opcode 62: advance Address by 4 to 0x401004 and Line by 1 to 3
  [0x00000047]  列幅を 5 に設定します
  [0x00000049]  Special opcode 217: advance Address by 15 to 0x401013 and Line by 2 to 5
  [0x0000004a]  列幅を 14 に設定します
  [0x0000004c]  Special opcode 75: advance Address by 5 to 0x401018 and Line by 0 to 5
  [0x0000004d]  列幅を 12 に設定します
  [0x0000004f]  Special opcode 91: advance Address by 6 to 0x40101e and Line by 2 to 7
  [0x00000050]  列幅を 1 に設定します
  [0x00000052]  Special opcode 76: advance Address by 5 to 0x401023 and Line by 1 to 8
  [0x00000053]  Advance PC by 2 to 0x401025
  [0x00000055]  拡張命令コード 1: 列の終り



</pre>


<p> 差分が保存されているので、人間には読みにくい表示になっているが、次の行を見てほしい。 </p>


<pre>
  [0x00000043]  Special opcode 6: advance Address by 0 to 0x401000 and Line by 1 to 2
</pre>

<p> これは、「前回のアドレスから、0byte進めた 0x401000 と、前回の行番号から1行進めた 2行目の位置が対応している」という情報だ。前回との差分は、今は見なくてよいので、ここでは、</p>

<pre>
  [0x00000043]  Special opcode 6: advance Address by 0 to <em>0x401000</em> and Line by 1 to <em>2</em>
</pre>

<p>
  この部分だけを見よう。0x401000 と 行番号2 が対応付けられているのが確認できるはずだ。同様に続きも見ていくと
</p>

<pre>
  [0x00000043]  Special opcode 6: advance Address by 0 to 0x401000 and Line by 1 to 2      # 0x401000 からは 2行目と対応
  [0x00000046]  Special opcode 62: advance Address by 4 to 0x401004 and Line by 1 to 3     # 0x401004 からは 3行目と対応
  [0x00000049]  Special opcode 217: advance Address by 15 to 0x401013 and Line by 2 to 5   # 0x401013 からは 5行目と対応
  [0x0000004c]  Special opcode 75: advance Address by 5 to 0x401018 and Line by 0 to 5     # 0x401018 からは 5行目と対応
  [0x0000004f]  Special opcode 91: advance Address by 6 to 0x40101e and Line by 2 to 7     # 0x40101e からは 7行目と対応
  [0x00000052]  Special opcode 76: advance Address by 5 to 0x401023 and Line by 1 to 8     # 0x401023 からは 8行目と対応
</pre>

<p>と、読みとれる(gccはカラム位置も含めて保存しているので、5行目が二回出てくる。とりあえず気にしないで読み進めてほしい)。さきほどのdisassembleやソースコードの表示とあわせると</p>

<table>
<tr>
<td>
<pre>
   0x0000000000401000 &lt;+0&gt;:	push   %rbp
   0x0000000000401001 &lt;+1&gt;:	mov    %rsp,%rbp
</pre>
</td>
<td>
 0x401000 からは 2行目と対応
</td>
<td>
<pre class="pygments">
<span class="kt">int</span> <span class="nf">_start</span><span class="p">()</span> <span class="p">{</span>
</pre>
</td>
</tr>

<tr>
<td>
<pre>
   0x0000000000401004 &lt;+4&gt;:	mov    0x2ff6(%rip),%eax        # 0x404000 &lt;a&gt;
   0x000000000040100a &lt;+10&gt;:	add    $0x1,%eax
   0x000000000040100d &lt;+13&gt;:	mov    %eax,0x2fed(%rip)        # 0x404000 &lt;a&gt;
</pre>
</td>
<td>
0x401004 からは 3行目と対応
</td>

<td>
<pre class="pygments">
    <span class="n">a</span><span class="o">++</span><span class="p">;</span>
</pre>
</td>

</tr>

<tr>
<td>
<pre>
   0x0000000000401013 &lt;+19&gt;:	mov    $0x0,%eax
</pre>
</td>

<td>
0x401013 からは 5行目と対応
</td>

<td>
<pre class="pygments">
    <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                       <span class="cm">/* アドレス0にアクセス、エラーを起こして停止させる */</span></pre>
</td>

</tr>

<tr>
<td>
<pre>
=&gt; 0x0000000000401018 &lt;+24&gt;:	movl   $0x0,(%rax)
</td>

<td>
0x401018 からは 5行目と対応
</td>

<td>
<pre class="pygments">
    <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                       <span class="cm">/* アドレス0にアクセス、エラーを起こして停止させる */</span></pre>
</td>

</tr>

<tr>
<td>
<pre>
   0x000000000040101e &lt;+30&gt;:	mov    $0xa,%eax
</pre>
</td>
<td>
0x40101e からは 7行目と対応
</td>

<td>
<pre class="pygments">
    <span class="k">return</span> <span class="mi">10</span><span class="p">;</span></pre>
</td>

<tr>
<td>
<pre>
   0x0000000000401023 &lt;+35&gt;:	pop    %rbp
   0x0000000000401024 &lt;+36&gt;:	ret    
</pre>
</td>
<td>
0x401023 からは 8行目と対応
</td>
<td>
<pre class="pygments">
<span class="p">}</span></pre>
</td>
</tr>
</table>

<p> 機械語のアドレス、デバッグ情報に保存された位置情報、ソースコードが、正しく対応していることを確認しよう。</p>

<p> (C言語のソースコードと機械語の対応については、C言語の章を参照してほしい <span class="kokomade">注意:まだ書いてない</span> )</p>

<p> ここまで見てきたアドレスとその情報の対応は、デバッグ情報の基本となる部分だ。次からは少し話がややこしくなるが、基本的な部分は変わらないので、「どうやってアドレスと情報を関連付けるか」という点を意識して読んでいってほしい。</p>


<h4> ローカル変数 </h4>

<p> ここまでの説明では、グローバルなアドレスとその情報の対応を見てきた。 </p>

<p>
  続いて、ローカル変数について考えよう。ローカル変数がグローバル変数と違う点は、変数のアドレスが実行時までわからない点だ。
  さらに、ローカル変数は、レジスタに割り当てられることがあり、そもそもアドレスが存在しないこともある。
</p>

<p>
  ここまで見てきたデバッグ情報では、リンク時に確定したアドレスだけが格納されていた。これではローカル変数のアドレスはわからない。
  単にアドレスをデバッグ情報に格納するよりもう少し何か対応が必要だ。その対応方法について説明しよう。
</p>

<p>
  次のプログラムを考えよう。
</p>


<p><a href="debuggee3.c"> debuggee3.c </a><p>
<div class="pygments"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;syscall.h&gt;</span><span class="cp"></span>

<span class="cm">/* 最適化で呼び出しが消えないようにGCC 11ではnoipaを付ける */</span>
<span class="cp">#define NOINLINE __attribute__((noipa))</span>

<span class="n">NOINLINE</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">ret1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">global</span><span class="p">;</span>

<span class="n">NOINLINE</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">ret1</span><span class="p">();</span>

  <span class="cm">/* わかりやすくするため、別の関数を呼んでeaxに入っている戻り値を強制的に別のレジスタに移動させる */</span>
  <span class="kt">int</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">ret1</span><span class="p">();</span>

  <span class="cm">/* わかりやすくするため、命令を一個入れる */</span>
  <span class="n">global</span><span class="o">++</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">x1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">_start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span>
    <span class="n">__asm__</span> <span class="nf">__volatile__</span><span class="p">(</span><span class="s">&quot;syscall&quot;</span><span class="o">::</span><span class="s">&quot;a&quot;</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span><span class="s">&quot;D&quot;</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>

<span class="p">}</span>
</pre></div>

<p>
  これは、変数がレジスタに乗るように書いたプログラムだ(レジスタを使うようにするために、最適化オプションを忘れないようにしよう)。
  コンパイラによって状況は変わる可能性があるが、手元のGCC11では x0 は ebxに割り当てられた。
</p>

<pre>
 $ gcc -S -no-pie -O2 -nostartfiles -nostdlib -fno-asynchronous-unwind-tables -o debuggee3.s debuggee3.c
</pre>

<div class="pygments"><pre><span></span>	<span class="na">.file</span>	<span class="s">&quot;debuggee3.c&quot;</span>
	<span class="na">.text</span>
	<span class="na">.p2align</span> <span class="mi">4</span>
	<span class="na">.type</span>	<span class="no">ret1</span><span class="p">,</span> <span class="na">@function</span>
<span class="nl">ret1:</span>
	<span class="nf">movl</span>	<span class="no">$1</span><span class="p">,</span> <span class="nv">%eax</span>
	<span class="nf">ret</span>
	<span class="na">.size</span>	<span class="no">ret1</span><span class="p">,</span> <span class="no">.-ret1</span>
	<span class="na">.p2align</span> <span class="mi">4</span>
	<span class="na">.type</span>	<span class="no">f</span><span class="p">,</span> <span class="na">@function</span>
<span class="nl">f:</span>
	<span class="nf">pushq</span>	<span class="nv">%rbx</span>
	<span class="nf">call</span>	<span class="no">ret1</span>
	<span class="nf">movl</span>	<span class="nv">%eax</span><span class="p">,</span> <span class="nv">%ebx</span>        <span class="cm">/* x0 はebxレジスタに乗る */</span>
	<span class="nf">call</span>	<span class="no">ret1</span>
	<span class="nf">addl</span>	<span class="no">$1</span><span class="p">,</span> <span class="no">global</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>
	<span class="nf">addl</span>	<span class="nv">%ebx</span><span class="p">,</span> <span class="nv">%eax</span>
	<span class="nf">popq</span>	<span class="nv">%rbx</span>
	<span class="nf">ret</span>
	<span class="na">.size</span>	<span class="no">f</span><span class="p">,</span> <span class="no">.-f</span>
	<span class="na">.p2align</span> <span class="mi">4</span>
	<span class="na">.globl</span>	<span class="no">_start</span>
	<span class="na">.type</span>	<span class="no">_start</span><span class="p">,</span> <span class="na">@function</span>
<span class="nl">_start:</span>
	<span class="nf">subq</span>	<span class="no">$8</span><span class="p">,</span> <span class="nv">%rsp</span>
	<span class="nf">call</span>	<span class="no">f</span>
	<span class="nf">movl</span>	<span class="nv">%eax</span><span class="p">,</span> <span class="nv">%edi</span>
	<span class="nf">movl</span>	<span class="no">$60</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="c1">#APP</span>
<span class="c1"># 27 &quot;debuggee3.c&quot; 1</span>
	<span class="nf">syscall</span>
<span class="c1"># 0 &quot;&quot; 2</span>
<span class="c1">#NO_APP</span>
	<span class="nf">addq</span>	<span class="no">$8</span><span class="p">,</span> <span class="nv">%rsp</span>
	<span class="nf">ret</span>
	<span class="na">.size</span>	<span class="no">_start</span><span class="p">,</span> <span class="no">.-_start</span>
	<span class="na">.globl</span>	<span class="no">global</span>
	<span class="na">.bss</span>
	<span class="na">.align</span> <span class="mi">4</span>
	<span class="na">.type</span>	<span class="no">global</span><span class="p">,</span> <span class="na">@object</span>
	<span class="na">.size</span>	<span class="no">global</span><span class="p">,</span> <span class="mi">4</span>
<span class="nl">global:</span>
	<span class="na">.zero</span>	<span class="mi">4</span>
	<span class="na">.ident</span>	<span class="s">&quot;GCC: (GNU) 11.1.0&quot;</span>
	<span class="na">.section</span>	<span class="no">.note.GNU-stack</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="na">@progbits</span>
</pre></div>


<p>
  これをgdbを経由して表示すると、
</p>

<pre>
 $ gcc -no-pie -O2 -g -nostartfiles -nostdlib -fno-asynchronous-unwind-tables -o debuggee3 debuggee3.c
</pre>

<pre>
 $ gdb --args ./debuggee3
Reading symbols from ./debuggee3...

(gdb) <span class="gdb-command">b f
</span>Breakpoint 1 at 0x401010: file debuggee3.c, line 13.
(gdb) <span class="gdb-command">run
</span>Starting program: /home/tanakmura/src/pllp/docs/debugger/debuggee3 

Breakpoint 1, f () at debuggee3.c:13
13	  int x0 = ret1();
(gdb) <span class="gdb-command">disassemble
</span>Dump of assembler code for function f:
=&gt; 0x0000000000401010 &lt;+0&gt;:	push   %rbx
   0x0000000000401011 &lt;+1&gt;:	call   0x401000 &lt;ret1&gt;
   0x0000000000401016 &lt;+6&gt;:	mov    %eax,%ebx
   0x0000000000401018 &lt;+8&gt;:	call   0x401000 &lt;ret1&gt;
   0x000000000040101d &lt;+13&gt;:	addl   $0x1,0xfdc(%rip)        # 0x402000 &lt;global&gt;
   0x0000000000401024 &lt;+20&gt;:	add    %ebx,%eax
   0x0000000000401026 &lt;+22&gt;:	pop    %rbx
   0x0000000000401027 &lt;+23&gt;:	ret    
End of assembler dump.
(gdb) <span class="gdb-command">print x0
</span>$1 = &lt;optimized out&gt;<span class="gdb-command-comment"><span class="gdb-command-comment"> # x0はまだ存在しない </span></span>
(gdb) <span class="gdb-command">nexti
</span>0x0000000000401011	13	  int x0 = ret1();
(gdb) <span class="gdb-command">nexti
</span>0x0000000000401016	13	  int x0 = ret1();
(gdb) <span class="gdb-command">disassemble
</span>Dump of assembler code for function f:
   0x0000000000401010 &lt;+0&gt;:	push   %rbx
   0x0000000000401011 &lt;+1&gt;:	call   0x401000 &lt;ret1&gt;
=&gt; 0x0000000000401016 &lt;+6&gt;:	mov    %eax,%ebx
   0x0000000000401018 &lt;+8&gt;:	call   0x401000 &lt;ret1&gt;
   0x000000000040101d &lt;+13&gt;:	addl   $0x1,0xfdc(%rip)        # 0x402000 &lt;global&gt;
   0x0000000000401024 &lt;+20&gt;:	add    %ebx,%eax
   0x0000000000401026 &lt;+22&gt;:	pop    %rbx
   0x0000000000401027 &lt;+23&gt;:	ret    
End of assembler dump.
(gdb) <span class="gdb-command">print x0
</span>$2 = &lt;optimized out&gt;<span class="gdb-command-comment"><span class="gdb-command-comment"> /* ebxに入っているx0が表示される */ </span></span>
</pre>



<p>
  正しく表示される。gdb はなんらかの方法で、x0 の位置がebxレジスタに割り当てられていることを把握できている。
</p>

<p>
  これは<em>機械語の命令毎に、変数の割り当て状況を記録していけば実現できる</em>。先程の例で、なんらかの方法で、
</p>

<div class="pygments"><pre><span></span><span class="nl">f:</span>
	<span class="nf">pushq</span>	<span class="nv">%rbx</span>			<span class="cm">/* まだローカル変数はない */</span>
	<span class="nf">call</span>	<span class="no">ret1</span> 			<span class="cm">/* この命令実行後に、戻り値がeaxに入っている */</span>
	<span class="nf">movl</span>	<span class="nv">%eax</span><span class="p">,</span> <span class="nv">%ebx</span>		<span class="cm">/* この命令実行後にx0 はebxレジスタに乗る */</span>
	<span class="nf">call</span>	<span class="no">ret1</span>			<span class="cm">/* この命令実行後に、戻り値がeaxに入っている、これがそのままx1になる。x0はebxレジスタにある */</span>	
	<span class="no">addl</span>	<span class="no">$1</span><span class="p">,</span> <span class="no">global</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>	<span class="cm">/* x0はebxレジスタにある。x1はeaxレジスタにある */</span>
	<span class="nf">addl</span>	<span class="nv">%ebx</span><span class="p">,</span> <span class="nv">%eax</span>		<span class="cm">/* 戻り値がeaxに入る、x1はeaxレジスタが書きかえられるので消滅する。x0はebxレジスタにある */</span>
	<span class="nf">popq</span>	<span class="nv">%rbx</span>			<span class="cm">/* ebxを復元、x0はebxレジスタが書きかえられるので消滅する */</span>
	<span class="nf">ret</span>				<span class="cm">/* ローカル変数はない */</span>
</pre></div>


<p> このコメントに書かれたような情報が記録されているとしよう。 </p>

<p>
  ソース位置への変換で見たように、デバッグ情報には、「機械語のアドレスと、その機械語のソースの位置の対応」を記録できる。
  それと同様に、<em>「機械語のアドレスと、その機械語における変数の割り当て状況」</em>が、記録されていれば、
  プログラムカウンタの位置から、その時の変数割り当ての状況が正しく把握できる。
</p>

<p>
  これまでと同じように readelf で見てみよう。今回は、-wi -wo を使う。-wi は、上で書いたとおり、.debug_infoセクションを表示する。今回は、これに加えて、-wo で .debug_loclists セクションも表示する。(-wi -wo は -wio と書いても同じ意味になる。どちらでも構わない)
</p>

<pre>
 $ readelf -wi -wo debuggee3 
.debug_info セクションの内容:

  コンパイル単位 @ オフセット 0x0:
   長さ:        0x108 (32-bit)
   バージョン:    5
   Unit Type:     DW_UT_compile (1)
   省略オフセット: 0x0
   ポインタサイズ:8
 &lt;0&gt;&lt;c&gt;: 省略番号: 3 (DW_TAG_compile_unit)
    &lt;d&gt;   DW_AT_producer    : (間接文字列、オフセット: 0xc): GNU C17 11.1.0 -mtune=generic -march=x86-64 -g -O2 -fno-asynchronous-unwind-tables
    &lt;11&gt;   DW_AT_language    : 29	(C11)
    &lt;12&gt;   DW_AT_name        : (間接行文字列、オフセット: 0x27): debuggee3.c
    &lt;16&gt;   DW_AT_comp_dir    : (間接行文字列、オフセット: 0x0): /home/tanakmura/src/pllp/docs/debugger
    &lt;1a&gt;   DW_AT_low_pc      : 0x401000
    &lt;22&gt;   DW_AT_high_pc     : 0x47
    &lt;2a&gt;   DW_AT_stmt_list   : 0x0
 &lt;1&gt;&lt;2e&gt;: 省略番号: 4 (DW_TAG_variable)
    &lt;2f&gt;   DW_AT_name        : (間接文字列、オフセット: 0x0): global
    &lt;33&gt;   DW_AT_decl_file   : 1
    &lt;34&gt;   DW_AT_decl_line   : 10
    &lt;35&gt;   DW_AT_decl_column : 5
    &lt;36&gt;   DW_AT_type        : &lt;0x44&gt;
    &lt;3a&gt;   DW_AT_external    : 1
    &lt;3a&gt;   DW_AT_location    : 9 byte block: 3 0 20 40 0 0 0 0 0 	(DW_OP_addr: 402000)
 &lt;1&gt;&lt;44&gt;: 省略番号: 5 (DW_TAG_base_type)
    &lt;45&gt;   DW_AT_byte_size   : 4
    &lt;46&gt;   DW_AT_encoding    : 5	(signed)
    &lt;47&gt;   DW_AT_name        : int
 &lt;1&gt;&lt;4b&gt;: 省略番号: 6 (DW_TAG_subprogram)
    &lt;4c&gt;   DW_AT_external    : 1
    &lt;4c&gt;   DW_AT_name        : (間接文字列、オフセット: 0x5f): _start
    &lt;50&gt;   DW_AT_decl_file   : 1
    &lt;51&gt;   DW_AT_decl_line   : 24
    &lt;52&gt;   DW_AT_decl_column : 1
    &lt;53&gt;   DW_AT_type        : &lt;0x44&gt;
    &lt;57&gt;   DW_AT_low_pc      : 0x401030
    &lt;5f&gt;   DW_AT_high_pc     : 0x17
    &lt;67&gt;   DW_AT_frame_base  : 1 byte block: 9c 	(DW_OP_call_frame_cfa)
    &lt;69&gt;   DW_AT_call_all_calls: 1
    &lt;69&gt;   DW_AT_sibling     : &lt;0x8e&gt;
 &lt;2&gt;&lt;6d&gt;: 省略番号: 1 (DW_TAG_variable)
    &lt;6e&gt;   DW_AT_name        : ret
    &lt;72&gt;   DW_AT_decl_file   : 1
    &lt;72&gt;   DW_AT_decl_line   : 26
    &lt;73&gt;   DW_AT_decl_column : 9
    &lt;74&gt;   DW_AT_type        : &lt;0x44&gt;
    &lt;78&gt;   DW_AT_location    : 0x10 (location list)
    &lt;7c&gt;   DW_AT_GNU_locviews: 0xc
 &lt;2&gt;&lt;80&gt;: 省略番号: 2 (DW_TAG_call_site)
    &lt;81&gt;   DW_AT_call_return_pc: 0x401039
    &lt;89&gt;   DW_AT_call_origin : &lt;0x8e&gt;
 &lt;2&gt;&lt;8d&gt;: Abbrev Number: 0
 &lt;1&gt;&lt;8e&gt;: 省略番号: 7 (DW_TAG_subprogram)
    &lt;8f&gt;   DW_AT_name        : f
    &lt;91&gt;   DW_AT_decl_file   : 1
    &lt;92&gt;   DW_AT_decl_line   : 12
    &lt;93&gt;   DW_AT_decl_column : 21
    &lt;94&gt;   DW_AT_prototyped  : 1
    &lt;94&gt;   DW_AT_type        : &lt;0x44&gt;
    &lt;98&gt;   DW_AT_low_pc      : 0x401010
    &lt;a0&gt;   DW_AT_high_pc     : 0x18
    &lt;a8&gt;   DW_AT_frame_base  : 1 byte block: 9c 	(DW_OP_call_frame_cfa)
    &lt;aa&gt;   DW_AT_call_all_calls: 1
    &lt;aa&gt;   DW_AT_sibling     : &lt;0xed&gt;
 &lt;2&gt;&lt;ae&gt;: 省略番号: 1 (DW_TAG_variable)
    &lt;af&gt;   DW_AT_name        : x0
    &lt;b2&gt;   DW_AT_decl_file   : 1
    &lt;b2&gt;   DW_AT_decl_line   : 13
    &lt;b3&gt;   DW_AT_decl_column : 7
    &lt;b4&gt;   DW_AT_type        : &lt;0x44&gt;
    &lt;b8&gt;   DW_AT_location    : 0x1f (location list)
    &lt;bc&gt;   DW_AT_GNU_locviews: 0x1b
 &lt;2&gt;&lt;c0&gt;: 省略番号: 1 (DW_TAG_variable)
    &lt;c1&gt;   DW_AT_name        : x1
    &lt;c4&gt;   DW_AT_decl_file   : 1
    &lt;c4&gt;   DW_AT_decl_line   : 16
    &lt;c5&gt;   DW_AT_decl_column : 7
    &lt;c6&gt;   DW_AT_type        : &lt;0x44&gt;
    &lt;ca&gt;   DW_AT_location    : 0x2c (location list)
    &lt;ce&gt;   DW_AT_GNU_locviews: 0x2a
 &lt;2&gt;&lt;d2&gt;: 省略番号: 2 (DW_TAG_call_site)
    &lt;d3&gt;   DW_AT_call_return_pc: 0x401016
    &lt;db&gt;   DW_AT_call_origin : &lt;0xed&gt;
 &lt;2&gt;&lt;df&gt;: 省略番号: 2 (DW_TAG_call_site)
    &lt;e0&gt;   DW_AT_call_return_pc: 0x40101d
    &lt;e8&gt;   DW_AT_call_origin : &lt;0xed&gt;
 &lt;2&gt;&lt;ec&gt;: Abbrev Number: 0
 &lt;1&gt;&lt;ed&gt;: 省略番号: 8 (DW_TAG_subprogram)
    &lt;ee&gt;   DW_AT_name        : (間接文字列、オフセット: 0x7): ret1
    &lt;f2&gt;   DW_AT_decl_file   : 1
    &lt;f3&gt;   DW_AT_decl_line   : 6
    &lt;f4&gt;   DW_AT_decl_column : 21
    &lt;f5&gt;   DW_AT_prototyped  : 1
    &lt;f5&gt;   DW_AT_type        : &lt;0x44&gt;
    &lt;f9&gt;   DW_AT_low_pc      : 0x401000
    &lt;101&gt;   DW_AT_high_pc     : 0x6
    &lt;109&gt;   DW_AT_frame_base  : 1 byte block: 9c 	(DW_OP_call_frame_cfa)
    &lt;10b&gt;   DW_AT_call_all_calls: 1
 &lt;1&gt;&lt;10b&gt;: Abbrev Number: 0

.debug_loclists セクションの内容:

    Offset   Begin            End              Expression

    0000000c v000000000000000 v000000000000000 location view pair
    0000000e v000000000000000 v000000000000000 location view pair

    00000010 v000000000000000 v000000000000000 views at 0000000c for:
             000000000040103b 0000000000401040 (DW_OP_reg0 (rax))
    00000015 v000000000000000 v000000000000000 views at 0000000e for:
             0000000000401040 0000000000401047 (DW_OP_reg5 (rdi))
    0000001a &lt;リストの終端&gt;

    0000001b v000000000000000 v000000000000000 location view pair
    0000001d v000000000000000 v000000000000000 location view pair

    0000001f v000000000000000 v000000000000000 views at 0000001b for:
             0000000000401018 000000000040101c (DW_OP_reg0 (rax))
    00000024 v000000000000000 v000000000000000 views at 0000001d for:
             000000000040101c 0000000000401027 (DW_OP_reg3 (rbx))
    00000029 &lt;リストの終端&gt;

    0000002a v000000000000000 v000000000000000 location view pair

    0000002c v000000000000000 v000000000000000 views at 0000002a for:
             000000000040101d 0000000000401026 (DW_OP_reg0 (rax))
    00000031 &lt;リストの終端&gt;


</pre>


<p> 表示された .debug_info から、x0 と x1 の情報を見てみよう。</p>

<pre>
 &lt;2&gt;&lt;ae&gt;: 省略番号: 1 (DW_TAG_variable)
    &lt;af&gt;   DW_AT_name        : x0
    &lt;b2&gt;   DW_AT_decl_file   : 1
    &lt;b2&gt;   DW_AT_decl_line   : 13
    &lt;b3&gt;   DW_AT_decl_column : 7
    &lt;b4&gt;   DW_AT_type        : &lt;0x44&gt;
    &lt;b8&gt;   DW_AT_location    : 0x1f (location list)
    &lt;bc&gt;   DW_AT_GNU_locviews: 0x1b
 &lt;2&gt;&lt;c0&gt;: 省略番号: 1 (DW_TAG_variable)
    &lt;c1&gt;   DW_AT_name        : x1
    &lt;c4&gt;   DW_AT_decl_file   : 1
    &lt;c4&gt;   DW_AT_decl_line   : 16
    &lt;c5&gt;   DW_AT_decl_column : 7
    &lt;c6&gt;   DW_AT_type        : &lt;0x44&gt;
    &lt;ca&gt;   DW_AT_location    : 0x2c (location list)
    &lt;ce&gt;   DW_AT_GNU_locviews: 0x2a
</pre>

<p> DW_AT_location が、(location list) というものに変化していることを確認しよう。グローバル変数の場合は、ここに絶対アドレスが書かれていた。
例えば、同じファイルに含まれているグローバル変数は、以下のようになっている。</p>

<pre>
 &lt;1&gt;&lt;2e&gt;: 省略番号: 4 (DW_TAG_variable)
    &lt;2f&gt;   DW_AT_name        : (間接文字列、オフセット: 0x0): global
    &lt;33&gt;   DW_AT_decl_file   : 1
    &lt;34&gt;   DW_AT_decl_line   : 10
    &lt;35&gt;   DW_AT_decl_column : 5
    &lt;36&gt;   DW_AT_type        : &lt;0x44&gt;
    &lt;3a&gt;   DW_AT_external    : 1
    &lt;3a&gt;   DW_AT_location    : 9 byte block: 3 0 20 40 0 0 0 0 0 	(DW_OP_addr: 402000)
</pre>

<p> ローカル変数の場合は、DW_AT_location に、ローカル変数用の位置情報が格納されている。この、location list の内容は、.debug_loclists セクションに書かれている。</p>

<pre>
.debug_loclists セクションの内容:

    Offset   Begin            End              Expression

    0000000c v000000000000000 v000000000000000 location view pair
    0000000e v000000000000000 v000000000000000 location view pair

    00000010 v000000000000000 v000000000000000 views at 0000000c for:
             000000000040103b 0000000000401040 (DW_OP_reg0 (rax))
    00000015 v000000000000000 v000000000000000 views at 0000000e for:
             0000000000401040 0000000000401047 (DW_OP_reg5 (rdi))
    0000001a &lt;リストの終端&gt;

    0000001b v000000000000000 v000000000000000 location view pair
    0000001d v000000000000000 v000000000000000 location view pair

    0000001f v000000000000000 v000000000000000 views at 0000001b for:
             0000000000401018 000000000040101c (DW_OP_reg0 (rax))
    00000024 v000000000000000 v000000000000000 views at 0000001d for:
             000000000040101c 0000000000401027 (DW_OP_reg3 (rbx))
    00000029 &lt;リストの終端&gt;

    0000002a v000000000000000 v000000000000000 location view pair

    0000002c v000000000000000 v000000000000000 views at 0000002a for:
             000000000040101d 0000000000401026 (DW_OP_reg0 (rax))
    00000031 &lt;リストの終端&gt;
</pre>

<p> x0 のDW_AT_locationは、</p>

<pre>
    &lt;b8&gt;   DW_AT_location    : 0x1f (location list)
</pre>

<p> このようになっていた。この、 "0x1f" が、location list 内の位置と対応している。</pre>

<pre>
    0000001f v000000000000000 v000000000000000 views at 0000001b for:   <em> # DW_AT_location の 0x1f と対応 </em>
             0000000000401018 000000000040101c (DW_OP_reg0 (rax))
    00000024 v000000000000000 v000000000000000 views at 0000001d for:
             000000000040101c 0000000000401027 (DW_OP_reg3 (rbx))
    00000029 &lt;リストの終端&gt;
</pre>

<p> これは、x0 の値が、0x401018 - 0x40101c の間は、rax に、0x40101c - 0x401027 の間は、rbx に格納されることを意味している。 </p>

<p> 同じように、x1 の location list は、DW_AT_location の値が、0x2c なので、 </p>

<pre>
    0000002c v000000000000000 v000000000000000 views at 0000002a for:
             000000000040101d 0000000000401026 (DW_OP_reg0 (rax))
    00000031 &lt;リストの終端&gt;
</pre>

<p> これと対応している。これは、x1 の値が、0x40101d - 0x401026 の間は、rax に格納されることを意味している。 </p>

<p> x0 の値がraxとrbxに重複して格納されている区間があるので、解釈の違いがあるが、これを正しく読み取れば、機械語毎に変数とレジスタが正しく対応付けられることを確認しよう。</p>

<p> x0 の loclistが、↓こうなっていて </p>
<table>
  <tr> <th> 開始 </th> <th> 終了 </th> <th>レジスタ</th> </tr>
  <tr> <td> 0x401018 </td> <td> 0x40101c </td> <td> rax </td> </tr>
  <tr> <td> 0x40101c </td> <td> 0x401027 </td> <td> rbx </td> </tr>
</table>

<p> x1 の loclistが、↓こうなっている </p>
<table>
  <tr> <th> 開始 </th> <th> 終了 </th> <th>レジスタ</th> </tr>
  <tr> <td> 0x40101d </td> <td> 0x401026 </td> <td> rax </td> </tr>
</table>

<p> これを機械語と対応させると </p>

<table>
  <tr>
    <th> アドレス </th> <th> 機械語 </th> <th> x0のレジスタ </th> <th> x1のレジスタ </th>
  </tr>

  <tr> <td> 0x401010 </td> <td> push %rbx </td> <td> 対応なし </td> <td> 対応なし </td> </tr>
  <tr> <td> 0x401011 </td> <td> call 0x401000 </td> <td> 対応なし </td> <td> 対応なし </td> </tr>
  <tr> <td> 0x401016 </td> <td> mov %eax, %ebx </td> <td> 対応なし </td> <td> 対応なし </td> </tr>
  <tr> <td> 0x401018 </td> <td> call 0x401000 </td> <td> rax </td> <td> 対応なし </td> </tr>
  <tr> <td> 0x40101d </td> <td> addl $0x1, 0xfdc(%rip) </td> <td> rbx </td> <td> rax </td> </tr>
  <tr> <td> 0x401024 </td> <td> add %ebx, %eax </td> <td> rbx </td> <td> rax </td> </tr>
  <tr> <td> 0x401026 </td> <td> pop %rbx </td> <td> rbx </td> <td> 対応なし </td> </tr>
  <tr> <td> 0x401027 </td> <td> ret </td> <td> 対応なし </td> <td> 対応なし </td> </tr>
</table>

<p> このようになる。 </p>

<p> この情報があれば、gdb の print x0 は、次のように実現できる。 </p>

<ol>
  <li> .debug_info から x0 の情報を取得する。x0 は loclist の 0x1f にあることがわかる </li>
  <li> loclist の 0x1f から、x0 の位置と機械語アドレスの対応を取得する </li>
  <li> 停止した位置のプログラムカウンタと、2. の対応をとって、x0 を格納しているレジスタの位置を取得する </li>
  <li> 対応するレジスタの値を取得して表示 </li>
</ol>

<p> readelf -wi -wo の出力から、ローカル変数の表示が実現できることを確認しよう。</p>

<div class="imgbox">
  <img src="addr_to_localvar.svg" width="100%">
</div>


<p> レジスタではなく、スタック上に確保された変数も見ておこう。 </p>


<p><a href="debuggee4.c"> debuggee4.c </a><p>
<div class="pygments"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;syscall.h&gt;</span><span class="cp"></span>

<span class="cm">/* 最適化で呼び出しが消えないようにGCC 11ではnoipaを付ける */</span>
<span class="cp">#define NOINLINE __attribute__((noipa))</span>

<span class="n">NOINLINE</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">ret1</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">NOINLINE</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">ret1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">_start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span>
    <span class="n">__asm__</span> <span class="nf">__volatile__</span><span class="p">(</span><span class="s">&quot;syscall&quot;</span><span class="o">::</span><span class="s">&quot;a&quot;</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span><span class="s">&quot;D&quot;</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>

<span class="p">}</span>
</pre></div>

<pre>
 $ gcc -fno-stack-protector -no-pie -O2 -g -nostartfiles -nostdlib -fno-asynchronous-unwind-tables -o debuggee4 debuggee4.c
</pre>

<pre>
 $ readelf -wi -wo debuggee4 
.debug_info セクションの内容:

  コンパイル単位 @ オフセット 0x0:
   長さ:        0xee (32-bit)
   バージョン:    5
   Unit Type:     DW_UT_compile (1)
   省略オフセット: 0x0
   ポインタサイズ:8
 &lt;0&gt;&lt;c&gt;: 省略番号: 1 (DW_TAG_compile_unit)
    &lt;d&gt;   DW_AT_producer    : (間接文字列、オフセット: 0x0): GNU C17 11.1.0 -mtune=generic -march=x86-64 -g -O2 -fno-stack-protector -fno-asynchronous-unwind-tables
    &lt;11&gt;   DW_AT_language    : 29	(C11)
    &lt;12&gt;   DW_AT_name        : (間接行文字列、オフセット: 0x0): debuggee4.c
    &lt;16&gt;   DW_AT_comp_dir    : (間接行文字列、オフセット: 0xc): /home/tanakmura/src/pllp/docs/debugger
    &lt;1a&gt;   DW_AT_low_pc      : 0x401000
    &lt;22&gt;   DW_AT_high_pc     : 0x47
    &lt;2a&gt;   DW_AT_stmt_list   : 0x0
 &lt;1&gt;&lt;2e&gt;: 省略番号: 2 (DW_TAG_subprogram)
    &lt;2f&gt;   DW_AT_external    : 1
    &lt;2f&gt;   DW_AT_name        : (間接文字列、オフセット: 0x6d): _start
    &lt;33&gt;   DW_AT_decl_file   : 1
    &lt;34&gt;   DW_AT_decl_line   : 16
    &lt;35&gt;   DW_AT_decl_column : 1
    &lt;36&gt;   DW_AT_type        : &lt;0x72&gt;
    &lt;3a&gt;   DW_AT_low_pc      : 0x401030
    &lt;42&gt;   DW_AT_high_pc     : 0x17
    &lt;4a&gt;   DW_AT_frame_base  : 1 byte block: 9c 	(DW_OP_call_frame_cfa)
    &lt;4c&gt;   DW_AT_call_all_calls: 1
    &lt;4c&gt;   DW_AT_sibling     : &lt;0x72&gt;
 &lt;2&gt;&lt;50&gt;: 省略番号: 3 (DW_TAG_variable)
    &lt;51&gt;   DW_AT_name        : ret
    &lt;55&gt;   DW_AT_decl_file   : 1
    &lt;56&gt;   DW_AT_decl_line   : 18
    &lt;57&gt;   DW_AT_decl_column : 9
    &lt;58&gt;   DW_AT_type        : &lt;0x72&gt;
    &lt;5c&gt;   DW_AT_location    : 0x10 (location list)
    &lt;60&gt;   DW_AT_GNU_locviews: 0xc
 &lt;2&gt;&lt;64&gt;: 省略番号: 4 (DW_TAG_call_site)
    &lt;65&gt;   DW_AT_call_return_pc: 0x401039
    &lt;6d&gt;   DW_AT_call_origin : &lt;0x79&gt;
 &lt;2&gt;&lt;71&gt;: Abbrev Number: 0
 &lt;1&gt;&lt;72&gt;: 省略番号: 5 (DW_TAG_base_type)
    &lt;73&gt;   DW_AT_byte_size   : 4
    &lt;74&gt;   DW_AT_encoding    : 5	(signed)
    &lt;75&gt;   DW_AT_name        : int
 &lt;1&gt;&lt;79&gt;: 省略番号: 6 (DW_TAG_subprogram)
    &lt;7a&gt;   DW_AT_name        : f
    &lt;7c&gt;   DW_AT_decl_file   : 1
    &lt;7d&gt;   DW_AT_decl_line   : 10
    &lt;7e&gt;   DW_AT_decl_column : 21
    &lt;7f&gt;   DW_AT_prototyped  : 1
    &lt;7f&gt;   DW_AT_type        : &lt;0x72&gt;
    &lt;83&gt;   DW_AT_low_pc      : 0x401010
    &lt;8b&gt;   DW_AT_high_pc     : 0x1b
    &lt;93&gt;   DW_AT_frame_base  : 1 byte block: 9c 	(DW_OP_call_frame_cfa)
    &lt;95&gt;   DW_AT_call_all_calls: 1
    &lt;95&gt;   DW_AT_sibling     : &lt;0xbc&gt;
 &lt;2&gt;&lt;99&gt;: 省略番号: 7 (DW_TAG_variable)
    &lt;9a&gt;   DW_AT_name        : x0
    &lt;9d&gt;   DW_AT_decl_file   : 1
    &lt;9e&gt;   DW_AT_decl_line   : 11
    &lt;9f&gt;   DW_AT_decl_column : 7
    &lt;a0&gt;   DW_AT_type        : &lt;0x72&gt;
    &lt;a4&gt;   DW_AT_location    : 2 byte block: 91 6c 	(DW_OP_fbreg: -20)
 &lt;2&gt;&lt;a7&gt;: 省略番号: 8 (DW_TAG_call_site)
    &lt;a8&gt;   DW_AT_call_return_pc: 0x401026
    &lt;b0&gt;   DW_AT_call_origin : &lt;0xbc&gt;
 &lt;3&gt;&lt;b4&gt;: 省略番号: 9 (DW_TAG_call_site_parameter)
    &lt;b5&gt;   DW_AT_location    : 1 byte block: 55 	(DW_OP_reg5 (rdi))
    &lt;b7&gt;   DW_AT_call_value  : 2 byte block: 91 6c 	(DW_OP_fbreg: -20)
 &lt;3&gt;&lt;ba&gt;: Abbrev Number: 0
 &lt;2&gt;&lt;bb&gt;: Abbrev Number: 0
 &lt;1&gt;&lt;bc&gt;: 省略番号: 10 (DW_TAG_subprogram)
    &lt;bd&gt;   DW_AT_name        : (間接文字列、オフセット: 0x68): ret1
    &lt;c1&gt;   DW_AT_decl_file   : 1
    &lt;c2&gt;   DW_AT_decl_line   : 6
    &lt;c3&gt;   DW_AT_decl_column : 21
    &lt;c4&gt;   DW_AT_prototyped  : 1
    &lt;c4&gt;   DW_AT_type        : &lt;0x72&gt;
    &lt;c8&gt;   DW_AT_low_pc      : 0x401000
    &lt;d0&gt;   DW_AT_high_pc     : 0x3
    &lt;d8&gt;   DW_AT_frame_base  : 1 byte block: 9c 	(DW_OP_call_frame_cfa)
    &lt;da&gt;   DW_AT_call_all_calls: 1
    &lt;da&gt;   DW_AT_sibling     : &lt;0xeb&gt;
 &lt;2&gt;&lt;de&gt;: 省略番号: 11 (DW_TAG_formal_parameter)
    &lt;df&gt;   DW_AT_name        : p
    &lt;e1&gt;   DW_AT_decl_file   : 1
    &lt;e2&gt;   DW_AT_decl_line   : 6
    &lt;e3&gt;   DW_AT_decl_column : 31
    &lt;e4&gt;   DW_AT_type        : &lt;0xeb&gt;
    &lt;e8&gt;   DW_AT_location    : 1 byte block: 55 	(DW_OP_reg5 (rdi))
 &lt;2&gt;&lt;ea&gt;: Abbrev Number: 0
 &lt;1&gt;&lt;eb&gt;: 省略番号: 12 (DW_TAG_pointer_type)
    &lt;ec&gt;   DW_AT_byte_size   : 8
    &lt;ed&gt;   DW_AT_type        : &lt;0x72&gt;
 &lt;1&gt;&lt;f1&gt;: Abbrev Number: 0

.debug_loclists セクションの内容:

    Offset   Begin            End              Expression

    0000000c v000000000000000 v000000000000000 location view pair
    0000000e v000000000000000 v000000000000000 location view pair

    00000010 v000000000000000 v000000000000000 views at 0000000c for:
             000000000040103b 0000000000401040 (DW_OP_reg0 (rax))
    00000015 v000000000000000 v000000000000000 views at 0000000e for:
             0000000000401040 0000000000401047 (DW_OP_reg5 (rdi))
    0000001a &lt;リストの終端&gt;


</pre>


<pre>
 &lt;2&gt;&lt;af&gt;: 省略番号: 8 (DW_TAG_variable)
    &lt;b0&gt;   DW_AT_name        : x0
    &lt;b3&gt;   DW_AT_decl_file   : 1
    &lt;b4&gt;   DW_AT_decl_line   : 13
    &lt;b5&gt;   DW_AT_decl_column : 7
    &lt;b6&gt;   DW_AT_type        : &lt;0x44&gt;
    &lt;ba&gt;   DW_AT_location    : 2 byte block: 91 6c 	(DW_OP_fbreg: -20)
</pre>

<p> この場合、x0 のDW_AT_locationは、 (DW_OP_fbreg: -20) となっている。これは、「この関数のフレームの開始位置から-20byteの所に格納されている」という意味だ。</p>

<pre>
 $ gcc -fno-stack-protector -no-pie -O2 -S -nostartfiles -nostdlib -fno-asynchronous-unwind-tables -o debuggee4.s debuggee4.c
</pre>

<div class="pygments"><pre><span></span>	<span class="na">.file</span>	<span class="s">&quot;debuggee4.c&quot;</span>
	<span class="na">.text</span>
	<span class="na">.p2align</span> <span class="mi">4</span>
	<span class="na">.type</span>	<span class="no">ret1</span><span class="p">,</span> <span class="na">@function</span>
<span class="nl">ret1:</span>
	<span class="nf">movl</span>	<span class="p">(</span><span class="nv">%rdi</span><span class="p">),</span> <span class="nv">%eax</span>
	<span class="nf">ret</span>
	<span class="na">.size</span>	<span class="no">ret1</span><span class="p">,</span> <span class="no">.-ret1</span>
	<span class="na">.p2align</span> <span class="mi">4</span>
	<span class="na">.type</span>	<span class="no">f</span><span class="p">,</span> <span class="na">@function</span>
<span class="nl">f:</span>
	<span class="nf">subq</span>	<span class="no">$24</span><span class="p">,</span> <span class="nv">%rsp</span>        <span class="cm">/* フレームサイズ24byte */</span>
	<span class="nf">leaq</span>	<span class="mi">12</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rdi</span>
	<span class="nf">movl</span>	<span class="no">$1</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>        <span class="cm">/* x0 = 1 */</span>
	<span class="nf">call</span>	<span class="no">ret1</span>
	<span class="nf">addq</span>	<span class="no">$24</span><span class="p">,</span> <span class="nv">%rsp</span>
	<span class="nf">ret</span>
	<span class="na">.size</span>	<span class="no">f</span><span class="p">,</span> <span class="no">.-f</span>
	<span class="na">.p2align</span> <span class="mi">4</span>
	<span class="na">.globl</span>	<span class="no">_start</span>
	<span class="na">.type</span>	<span class="no">_start</span><span class="p">,</span> <span class="na">@function</span>
<span class="nl">_start:</span>
	<span class="nf">subq</span>	<span class="no">$8</span><span class="p">,</span> <span class="nv">%rsp</span>
	<span class="nf">call</span>	<span class="no">f</span>
	<span class="nf">movl</span>	<span class="nv">%eax</span><span class="p">,</span> <span class="nv">%edi</span>
	<span class="nf">movl</span>	<span class="no">$60</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="c1">#APP</span>
<span class="c1"># 19 &quot;debuggee4.c&quot; 1</span>
	<span class="nf">syscall</span>
<span class="c1"># 0 &quot;&quot; 2</span>
<span class="c1">#NO_APP</span>
	<span class="nf">addq</span>	<span class="no">$8</span><span class="p">,</span> <span class="nv">%rsp</span>
	<span class="nf">ret</span>
	<span class="na">.size</span>	<span class="no">_start</span><span class="p">,</span> <span class="no">.-_start</span>
	<span class="na">.ident</span>	<span class="s">&quot;GCC: (GNU) 11.1.0&quot;</span>
	<span class="na">.section</span>	<span class="no">.note.GNU-stack</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="na">@progbits</span>
</pre></div>



<p>
  出力されたアセンブリを見ると、まず、rsp を 24byte 減らして、スタックフレームを確保し、rsp + 12 の位置にx0 を確保していることがわかる。
  これは、関数の開始時点から見ると、rsp-12 の位置にx0を確保していることになる。
  DWARFでは、スタックフレームは、関数の戻りアドレスを含めるので、スタックフレームの開始位置は、関数開始時点のrspの位置から、+8した位置になる。
</p>

<div class="imgbox">
  <img src="jtagdebug.svg" width="100%">
</div>

<p> フレーム開始位置から、-20byteの位置にx0が確保されていることを確認してほしい。 </p>

<p> このように、スタックに確保されたローカル変数は、デバッグ情報の中にフレームからの距離が格納されている。 </p>

<p> gdb の print は、</p>

<ol>
  <li> .debug_info から x0 の情報を取得する。x0 は今のフレームの-20byteにあることがわかる </li>
  <li> フレーム開始位置から-20byteの位置から値を取得して表示 </li>
</ol>

<p> と、なる。 </p>

<p> さて、ここで注意してほしいのは、「フレーム開始位置」とは一体なんなのか？という点だ。 </p>

<p> フレーム開始位置は、rsp の付近にあるということは予測できるが、rspの値は、プログラムの実行にあわせて変化するので、
  「関数Xでは、rsp から N byte 離れた位置がフレーム開始位置になる」とは言えない。
</p>

<p>たとえば、先程のアセンブリで考えると</p>

<div class="pygments"><pre><span></span><span class="nl">f:</span>                                    <span class="c1"># fの開始時点では rsp+8 がフレーム開始位置</span>
	<span class="nf">subq</span>	<span class="no">$24</span><span class="p">,</span> <span class="nv">%rsp</span>             <span class="c1"># この命令の実行後は rsp+32 がフレーム開始位置</span>
	<span class="nf">leaq</span>	<span class="mi">12</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rdi</span>
	<span class="nf">movl</span>	<span class="no">$1</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
	<span class="nf">call</span>	<span class="no">ret1</span>		      <span class="c1"># call 命令はrspを8減らすのでcallで飛んだ先ではrsp+40がフレーム開始位置、戻ってくるとrsp+32がフレーム開始位置</span>
	<span class="nf">addq</span>	<span class="no">$24</span><span class="p">,</span> <span class="nv">%rsp</span>             <span class="c1"># この命令の実行後は rsp+8 がフレーム開始位置</span>
	<span class="nf">ret</span>
</pre></div>


<p> このように、rsp とフレーム開始位置の距離は変化する。 </p>

<p> フレームの開始位置を正しく表現するには、どういう情報をデバッグ情報に含めればよいだろうか。
  これについては、次のbacktraceのところで解説しよう。 </p>

<h4> backtrace </h4>


<h3> breakpoint,next,finish </h3>
<h3> watch </h3>

<h1> デバッガの実装 </h1>

<p> さらに完全に理解したい人のために、デバッガを実装してみよう。(ほんとにやるの？) </p>

<h2> DWARFの読みかた </h2>

<p> <a href="../index.html"> 戻る </a> </p>

</div>

</body>
</html>