<html>
<head>
  <meta charset="utf-8"/>
  <title> リンカ </title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>

<p> <a href="index.html"> 戻る </a> </p>

<h2> <a href="asm_language.html"> リンカ </a> </h2>

  <p>
    ついに、リンカの説明をするときが来た。
  </p>

  <p>
    ここに至るまでに、何度「リンカのところで説明する」と書いただろうか？
    ここまで読んできた人ならば、
    リンカというものが、なにやら色々やっているんだな、というのはわかってきたのではないかと思う。
  </p>

  <p>
    筆者が常々思っていることのひとつに、「C言語に関する書籍は、リンカの説明をおざなりにしすぎだ」というのがある。
  </p>
  <p>
    多くのC言語の書籍は、
  </p>
  <ol>
    <li> コンパイラがソースコードをアセンブリコードに変換します </li>
    <li> アセンブラがアセンブリコードを機械語に変換します </li>
    <li> リンカが機械語をリンクして実行ファイルが作られます </li>
  </ol>

  <p>
    と、いう解説がなされがちである。この説明を見たら、多くの人が、「え、リンクってなんですか？」と、思うに違いない。
  </p>
  <p>
    アセンブラには、「人間が読めるニーモニックを、機械が読める機械語に変換する」みたいな、最低限の説明が付くものの、
    リンカの説明は「リンクをします」のひとことだけである！
  </p>

  <p>
    ここでは、いつも雑な説明をされがちな、リンカについて説明をしていきたいと思う。
  </p>

  <p>
    C言語の言語仕様には、明示的にリンクについて書かれてはいないものの、
    extern 指定子など、言語仕様の一部に、リンクの処理を無視して説明できない仕様を含んでいるのは間違いない。
    リンクについて知れば、C言語への理解も、もう一歩深まるだろう。
  </p>

  <h3> コンパイラドライバ、libc、スタートアップルーチン </h3>
<p> リンカの説明前にいくつか必要な説明をしておこう。 </p>

<p> <a href="link/main.s"> link/main.s </a> </p>

<pre>
	.globl	main
main:
	ret
</pre>

<p>
  このプログラムを gcc -static でコンパイルして、objdump -d で逆アセンブルを確認してほしい。
  main 関数に含まれる命令は1個しかないのに、実際の実行ファイルには大量の命令が含まれていることが確認できるはずだ。
  この大量の命令は、<em>libc</em>と呼ばれるライブラリ等から来る命令だ。
</p>

<p>
  <em> libc </em> は、C言語の仕様を満たすために定義された関数、データを含むライブラリだ。
  Cを書いたことがある人なら、printf、malloc などの関数を使ったことがあるだろう。
  printf関数やmalloc関数はこの、libc の中に実装されている。
  libc には、いくつか種類があって、x86_64 の Linux では、glibc(The GNU C Library) と呼ばれるlibcが使われている。
  Windows では、msvcrt(Microsoft Visual Studio C Runtime か?)と呼ばれるlibcが使われることが多い。
</p>

<p>
  実際には、Linux上のgccでビルドした場合、libcの他に、<em>スタートアップルーチン</em>と、<em>libgcc</em> がリンクされる。
  これらの詳細については、またあとでlibcのところで説明しよう。
</p>

<p>
  ここで、"gcc" というコマンドが、.s を変換するだけでなく、libcとのリンクも行っている点に注意しよう。
  ついでに、これまでも "gcc" というコマンドを使って、アセンブリ(.s) を実行ファイル(a.out) に変換していたことを思い出して欲しい。
</p>

<p>
  "gcc"というコマンドは、その名前に反して、*Cコンパイラではない*！
  "gcc"は、<em>コンパイラドライバ (compiler driver)</em>と呼ばれるプログラムで、
  ソースコードファイルを実行ファイルに変換する時に必要なコマンドを良い感じに呼び出してくれるツールだ。
</p>

<p>
  <em>コンパイラドライバ</em>の挙動は、仕様もなく、ドキュメンテーションもされておらず、OS、コンパイラ毎に挙動がマチマチで、
  「良い感じに」処理してくれるとしか言いようのない動作をする。
</p>

<p>
  Linux 上の gcc コンパイラドライバは、大体以下のような動作をする。(実際には色々オプションによって挙動変わるので、もう少し複雑だ。ちなみに、clang はこの動作をかなりの精度で再現する)
</p>

<ul>
  <li> 引数に .c というファイルが渡された場合は、gcc に含まれる cc1 (これが本物のCコンパイラのコマンドだ) を呼び出して .c を .s に変換する </li>
  <li> 引数に .cpp, .f, .java, など、各種ソースが渡された場合は、.c と同様に対応するコンパイラを呼び出して .s に変換する </li>
  <li> 引数に -S が付いていない場合は、as (アセンブラ)を呼び出して cc1 などが出力した .s、引数に渡された.s を .o に変換する (-S が付けられた場合は、.oに変換せず、.s を出力する) </li>
  <li> 引数に -c が付いていない場合は、ld (リンカ)を呼び出して引数に渡されたソースを.oに変換したものと libc、-l オプションで渡された追加のライブラリをリンクする (-c が付けられた場合は、リンクしないで、.o を出力する) </li>
</ul>

<p>
  ld(リンカ) は gcc から呼ばれるときは、collect2 というラッパーを経由して呼ばれるが、
  現代ではLTO(Link Time Optimization) を使わない場合はcollect2 = ld と解釈してもらって構わない。(TODO : collect2 が必要な理由を調べる)。
</p>

<p>
  gcc に、-v を付けると、実際に背後でどういうコマンドが実行されるか確認できる。
</p>

<pre>
$ gcc -v a.c
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/5/lto-wrapper
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion=&39;Ubuntu 5.4.0-6ubuntu1~16.04.9&39; --with-bugurl=file:///usr/share/doc/gcc-5/README.Bugs --enable-languages=c,ada,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-5 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-5-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-5-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-5-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9)
COLLECT_GCC_OPTIONS=&39;-v&39; &39;-mtune=generic&39; &39;-march=x86-64&39;
 /usr/lib/gcc/x86_64-linux-gnu/5/cc1 -quiet -v -imultiarch x86_64-linux-gnu a.c -quiet -dumpbase a.c -mtune=generic -march=x86-64 -auxbase a -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/cc8AbPic.s   <em> # cc1 を呼んでいる </em>
GNU C11 (Ubuntu 5.4.0-6ubuntu1~16.04.9) version 5.4.0 20160609 (x86_64-linux-gnu)
        compiled by GNU C version 5.4.0 20160609, GMP version 6.1.0, MPFR version 3.1.4, MPC version 1.0.3
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
ignoring nonexistent directory &quot;/usr/local/include/x86_64-linux-gnu&quot;
ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/5/../../../../x86_64-linux-gnu/include&quot;
#include &quot;...&quot; search starts here:
#include &lt;...&gt; search starts here:
 /usr/lib/gcc/x86_64-linux-gnu/5/include
 /usr/local/include
 /usr/lib/gcc/x86_64-linux-gnu/5/include-fixed
 /usr/include/x86_64-linux-gnu
 /usr/include
End of search list.
GNU C11 (Ubuntu 5.4.0-6ubuntu1~16.04.9) version 5.4.0 20160609 (x86_64-linux-gnu)
        compiled by GNU C version 5.4.0 20160609, GMP version 6.1.0, MPFR version 3.1.4, MPC version 1.0.3
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
Compiler executable checksum: d079eab342c322d6be59e8628e10ae67
COLLECT_GCC_OPTIONS=&39;-v&39; &39;-mtune=generic&39; &39;-march=x86-64&39;
 as -v --64 -o /tmp/ccNgb4Ka.o /tmp/cc8AbPic.s      <em> # as を呼んでいる </em>
GNU assembler version 2.26.1 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.26.1
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/5/:/usr/lib/gcc/x86_64-linux-gnu/5/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/5/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/5/:/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/5/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/5/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS=&39;-v&39; &39;-mtune=generic&39; &39;-march=x86-64&39;
 /usr/lib/gcc/x86_64-linux-gnu/5/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/5/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/5/lto-wrapper -plugin-opt=-fresolution=/tmp/ccqaqkj9.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/5/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/5 -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/5/../../.. /tmp/ccNgb4Ka.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/5/crtend.o /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crtn.o <em> # collect2 を呼んでいる </em>
</pre>

<p>
  cc1, as, collect2 コマンドが呼ばれていることを確認しよう。また、わかりにくいが、リンク時に、crtなんとか.o と、-lc -lgcc をリンクしていることも見ておいてほしい。
  crtなんとか.o がスタートアップルーチンを含むオブジェクト、-lc が libc、-lgcc が、libgcc だ。
</p>

<p>
  昔は、Cのプリプロセッサは独立したコマンドとして呼ばれていたが、今のCコンパイラは、Cプリプロセッサを内蔵しており、プリプロセスしながらコンパイルを行う。
  そのため、通常はプリプロセッサが単体で呼ばれることはない。(-E オプションを付けてgccを呼び出せば明示的にプリプロセスだけを実行させることはできる)
</p>

<p>
  cc1 は gcc の内部コマンドなので、シェルから呼び出すことはできない。上の -v の出力で出てきたcc1のパスを直接実行しよう。
</p>

<pre>
$ cat a.c
int main() { }
$ /usr/lib/gcc/x86_64-linux-gnu//5/cc1 a.c
 main
Analyzing compilation unit
Performing interprocedural optimizations
 &lt;*free_lang_data&gt; &lt;visibility&gt; &lt;build_ssa_passes&gt; &lt;opt_local_passes&gt; &lt;free-inline-summary&gt; &lt;whole-program&gt; &lt;inline&gt;Assembling functions:
 main
Execution times (seconds)
 phase setup             :   0.00 ( 0%) usr   0.00 ( 0%) sys   0.01 (50%) wall    1093 kB (85%) ggc
 phase finalize          :   0.00 ( 0%) usr   0.00 ( 0%) sys   0.01 (50%) wall       0 kB ( 0%) ggc
 TOTAL                 :   0.00             0.00             0.02               1286 kB
</pre>

<p>
  cc1 に a.c を渡すと、a.s というアセンブリファイルが出力されるており、cc1 が「Cソースをアセンブリに変換する」という教科書どおりのコンパイラの動作をしていることを確認しよう。
  cc1 は、内部コマンドなので、ユーザが直接使うことは想定されておらず、オプション等はGCCのバージョンによって大きく変わる。筆者もあんまり把握していないので、詳しい説明は省略する。
</p>

<p>
  as は Linux標準のアセンブラだ。アセンブリをオブジェクトコードに変換する。
  これまで書いてきたいくつかのアセンブリのソースを、as を使って変換してみよう。
</p>
<pre>
$ as main.s 
$ ls 
a.out  main.s
</pre>

<p>
  gcc -c で main.s をアセンブルした時は、main.o に出力してくれるが、as でアセンブルすると、指定しないと a.out というファイルになる。
  紛らわしいが、この a.out は実行できるファイルではない。
</p>

<p>
  as でアセンブルした場合と、 gcc で実行できるa.outを作った場合で、ファイルタイプが異なる。
  readelf -h は、オブジェクトファイルのヘッダ情報を出力するコマンドだ。
  これを見ると実行できるファイルかどうか判断できる。
</p>

<pre>
$ as main.s
$ readelf -h a.out
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)         <em> # Type が REL </em>
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          320 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         8
  Section header string table index: 5
$ gcc -no-pie main.s
$ readelf -h a.out
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)         <em> # Type が EXEC </em>
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x400430
  Start of program headers:          64 (bytes into file)
  Start of section headers:          6592 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         31
  Section header string table index: 28
</pre>

<p> これはどういうことなのか、というのが、このリンクの章で説明したいことだ。あとでじっくり説明するので、少々お待ちください。</p>

<p> a.out 以外のファイル名で出力する場合は、-o &lt;ファイル名&gt; オプションを使う。 </p>


<p>
  最後にld。ld は、Linux標準のリンカだ。リンカは、アセンブラが出力したオブジェクトをリンクし、実行ファイルや共有ライブラリを出力する。
</p>

<pre>
$ cat main.s
	.globl	main
main:
	ret
$ as main.s -o main.o
$ ld main.o -o a.out
/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000400078
$ readelf -h a.out
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)          <em> 実行ファイル </em>
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x400078
  Start of program headers:          64 (bytes into file)
  Start of section headers:          360 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         1
  Size of section headers:           64 (bytes)
  Number of section headers:         5
  Section header string table index: 2
$ ./a.out
segmentation fault (core dumped)
</pre>

<p> ld を使って、main.o をリンクすると、今度は、きちんと実行できるファイルが出力されていることを確認しよう。 </p>

<p> しかし、この実行ファイルは、実行はできるものの、実行すると正常終了しない。</p>

<pre>
(gdb) b main
Breakpoint 1 at 0x400078
(gdb) start
Temporary breakpoint 2 at 0x400078
Starting program: /mnt/d/wsl/src/pllp/docs/link/x/a.out 

Breakpoint 1, 0x0000000000400078 in main ()
(gdb) x/4i $pc
=&gt; 0x400078 &lt;main&gt;:	retq   
   0x400079:	add    %al,(%rax)
   0x40007b:	add    %al,(%rax)
   0x40007d:	add    %al,(%rax)
(gdb) p $rsp
$1 = (void *) 0x7ffffffee4f0
(gdb) p *(void**) $rsp
$2 = (void *) 0x1
(gdb) stepi
0x0000000000000001 in ?? ()
(gdb) stepi
</pre>

<p> プログラムの最後に ret 命令を書いていたが、 rsp が指す先には、戻りアドレスは存在していない。(プログラムカウンタが1になっている点を確認しよう) </p>

<p> これは、スタートアップルーチンをリンクしていないためだ。 </p>

<p>
  スタートアップルーチンは、mainを呼んだあとにもいくらかの後処理をする。
  スタートアップルーチンを正しくリンクした場合、プログラムカウンタが main に来たときは、
  スタックにmainの後処理をするアドレスが積まれている。
  なので、gccコンパイラドライバを使ってリンクした場合には、main から単に ret するだけで、プログラムが正しく終了できる。
</p>

<p>
  mainのあとに必要な処理はいくつかあるが、一番重要なのは、OSに対してプログラムの終了を依頼することだ。
  詳細はシステムコールのところで説明するが、x86_64 では、rax レジスタに 60 を設定して、syscall 命令を実行すればよい。
</p>

<p> <a href="link/exit.s"> link/exit.s </a> </p>

<pre>
	.globl	main
main:
	mov	$60, %rax
	syscall
</pre>

<pre>
$ as exit.s -o exit.o
$ ld exit.o -o a.out
/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000400078
$ ./a.out
</pre>

<p> プログラムが正しく終了した。 </p>

<p>
  "/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000400078"
  が気になるので、これも説明しておこう。
</p>

<p>
  さきほど書いたように、コンパイラドライバ経由でリンクされたオブジェクトは、スタートアップルーチンで初期化をする。
  これはつまり、main の前にいくらかプログラムが動いているわけで、プログラムの本当の開始位置は、main ではないのだ。
</p>

<p>
  ld では、オプション無しでオブジェクトをリンクすると、mainではなく、"_start" ラベルが置かれた位置をプログラム開始位置とする、と決められている
  (興味がある人は、gdb で _start にブレークポイントを置いてプログラムを実行してみよう)。
  "cannot find entry symbol _start" というのは、この "_start" ラベルが見つからないという意味だ。
</p>

<p> プログラムの起動と終了を要約すると、以下のようになる。 </p>

<ol>
  <li> _start ラベルが置かれた位置からプログラムスタート </li>
  <li> スタートアップルーチンが初期化する </li>
  <li> スタートアップルーチンが main を call する </li>
  <li> main でユーザが書いたプログラムを処理 </li>
  <li> main から ret </li>
  <li> スタートアップルーチンに戻ってくる </li>
  <li> 終了処理 </li>
  <li> OS に終了依頼 </li>
</ol>

<p>
  通常、コンパイラドライバ経由でオブジェクトをリンクした場合、スタートアップルーチンがリンクされるが、
  今は、スタートアップルーチンをリンクしないで実行ファイルを作っているので、最初の _start が定義されてない。
  よって、"cannot find entry symbol _start"という警告が出るのだ。
</p>

<p>
  自分で _start を定義してスタートアップルーチンを書いてみよう。
  と、いってもやることは、1. mainを呼ぶ 2. mainが終わったら終了する の二個だけだ。
</p>

<p> <a href="link/start_exit.s"> link/start_exit.s </a> </p>

<pre>
	.globl	_start

_start:
	call	main
	mov	$60, %rax
	syscall

main:
	ret

</pre>

<pre>
$ as start_exit.s -o start_exit.o
$ ld start_exit.o -o a.out
$ ./a.out
</pre>

<p> これで警告も出ないし、正しく終了できる実行ファイルが作れた。 </p>

<p> 以上、コンパイラドライバの内容と、コンパイラドライバを使わないで、アセンブル、リンクを行う方法について簡単に説明した。 </p>

<p> 色々はしょって解説したのでわかりにくかったかもしれないが、
  コンパイラドライバは、環境やバージョンによって動作が変わるので、あんまり細かい挙動について理解する必要はなくて、
  「コンパイラ、アセンブラ、リンカを順番に呼び出しているんだな」程度に理解してもらえればよいと思う。
</p>

<p> これでリンカを単体で使う方法を説明できたので、いよいよ次はリンカの説明に入っていこう。 </p>

  <h3> リンクとはなにか </h3>
  <p> リンカがやっていることは、主に</p>
  <ul>
    <li> オブジェクトをくっつけて一個にする </li>
    <li> ラベルへの参照を解決する </li>
  </ul>

  <p> の二点だ。</p>

<p> 次のふたつのファイルをリンクしてみよう。</p>

<p>
  <a href="link/link0.s"> link/link0.s </a>
</p>
<pre>
	.globl	_start
_start:
	ret

</pre>

<p>
  <a href="link/link1.s"> link/link1.s </a>
</p>

<pre>
	nop
</pre>

<pre>
$ as link0.s -o link0.o
$ as link1.s -o link1.o
$ ld link0.o link1.o
$ objdump -d a.out

a.out:     file format elf64-x86-64


Disassembly of section .text:

0000000000400078 &lt;_start&gt;:
  400078:	c3                   	retq   
  400079:	90                   	nop

</pre>

<p> link0.s の ret 命令と、link1.s の nop 命令が一個のa.outにまとめられていることを確認してほしい </p>

<p>
  リンカの挙動を決める仕様は存在していないが、世の中の大体のリンカは、引数に指定した順にオブジェクトを並べていく。
  引数のファイルの順序を変えると、並ぶ命令の順序も変わる。
</p>

<pre>
$ ld link1.o link0.o 
$ objdump -d a.out

a.out:     file format elf64-x86-64


Disassembly of section .text:

0000000000400078 &lt;_start-0x1&gt;:
  400078:	90                   	nop

0000000000400079 &lt;_start&gt;:
  400079:	c3                   	retq   
</pre>

<p> C++ のグローバル変数のコンストラクタの呼び出し順などは、この順序で決まる実装が多いので、覚えておくと何かの役に立つかもしれない。 </p>

<p>
  続いて、リンカの重要な仕事が、ラベル参照の解決だ。これまでにも簡単に解説してきたが、あらためて説明しておこう。
</p>

<p>
  アセンブリファイル中には、ラベルが置ける。プログラムに含まれる命令、データは、リンクが終わるまでアドレスが確定しないが、
  ラベルを使うことで、リンク後に決まるアドレスの値を確定前に参照することができる。
</p>

<p> <a href="link/link_label0.s"> link/link_label0.s </a> </p>
<pre>
	.globl	_start
_start:
	mov	$label0, %rax
</pre>

<p> <a href="link/link_label1.s"> link/link_label1.s </a> </p>
<pre>
	.globl	label0
label0:
	mov	$_start, %rax
</pre>

<pre>
$ as link_label0.s -o link_label0.o
$ as link_label1.s -o link_label1.o
$ objdump -d link_label0.o

link_label0.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
$ objdump -d link_label1.o

link_label1.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;label0&gt;:
   0:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
$ ld link_label0.o link_label1.o 
$ objdump -d a.out

a.out:     file format elf64-x86-64


Disassembly of section .text:

0000000000400078 &lt;_start&gt;:
  400078:	48 c7 c0 7f 00 40 00 	mov    $0x40007f,%rax

000000000040007f &lt;label0&gt;:
  40007f:	48 c7 c0 78 00 40 00 	mov    $0x400078,%rax
</pre>

<p>
  リンクすると、_start ラベルが置かれたアドレスが0x400078、label0 ラベルが置かれたアドレスが0x40007d と確定する。
  リンク前は 0 だった mov 命令のオペランドが、リンク後には確定されたラベルのアドレスに書き換わっている点を確認しよう。
  このように、オブジェクト内に含まれているラベルへの参照を、確定したアドレスに書きかえることを「解決する(resolve)」と言う。
</p>

<p> このラベルの解決をするためにアセンブラ、リンカが何をやっているかを見ていこう。</p>

  <h3> シンボル、リロケーション </h3>

<p> オブジェクトファイルには、機械語、データの他に、ラベルの解決に必要な情報が含まれている。
  <em>シンボル (symbol)</em> と <em>リロケーション(relocation)</em>だ。
</p>

<p>
  <em> シンボル </em> は、アドレスを識別する文字表現を保持しておく情報だ。
  アセンブリ言語で書かれたラベルは、このシンボルに変換されて、オブジェクトファイル内に保持される。
  また、デバッガやリンカの動作を助けるために、追加の情報が付けられることもある。
</p>

<h4> シンボル </h4>

<p>
  <em> シンボル </em> には <em> 定義済みシンボル (defined symbol) </em>、<em> 未定義シンボル (undefined symbol) </em> の二種類がある。
</p>

<p>
  <em> 定義済みシンボル </em> は、ラベル等を使ってファイル内に定義された実体が存在するシンボルだ。
  定義済みシンボルは、ファイル内で定義された位置のオフセットと、追加情報、文字列表現の情報を持つ。
</p>

<p>
  <em> 未定義シンボル </em> は、オブジェクトファイル中に実体が存在しないシンボルだ。
  未定義シンボルは、あとでリンクするときのために文字列と追加情報を持ち、定義済みシンボルと違って定義された位置のオフセットは持たない。
</p>

<p>
  このあたりの定義もかなり曖昧で、単にシンボルと言うときは、定義済みシンボルのことを指すことが多い。
  毎回"定義済みシンボル"と表記するのはあまり一般的ではないが、
  このリンカの章では、説明の曖昧さをなくすために、毎回"定義済みシンボル"と書くことにする。
  他の章では、慣習に従って、必要のないときは"定義済みシンボル"の意味で"シンボルと書くことにしよう。
</p>

<p>
  "ラベル" と "定義済みシンボル" は、かなり似たものになる。
  何が違うか…というのは…筆者もあまり把握していないが…
  アセンブリ言語などの、ソースコード中に目印として置かれるものは"ラベル"、
  オブジェクトに含まれている情報は"シンボル"、と呼ばれることが多いように思う。
</p>

<p>
  オブジェクト内に含まれる"定義済みシンボル"を"ラベル"と呼ぶことはあまりないので、その慣習にしたがって以下では、
  ソースコードに貼られた情報をラベル、オブジェクト内に含まれた情報を定義済みシンボルと呼ぶことにする。
  (あまり厳密な使いわけはされてないと思うので、呼び間違えても話は通じるはず)
</p>

<p>
  これまで何度か使ってきたreadelfに"-s"を付けて実行すると、オブジェクトに含まれる定義済みシンボル、未定義シンボルの情報を表示することができる。
</p>

<p> <a href="link/defsym.s"> link/defsym.s </a> </p>

<pre>
	.globl	_start
	.globl	sym0
_start:
	nop

sym0:
	nop
sym1:
	nop
	nop
	nop
	nop
sym2:
	nop

</pre>

<p>--</p>

<pre>
$ readelf -s defsym.o

Symbol table &39;.symtab&39; contains 8 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
     4: 0000000000000002     0 NOTYPE  LOCAL  DEFAULT    1 sym1
     5: 0000000000000006     0 NOTYPE  LOCAL  DEFAULT    1 sym2
     6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT    1 _start
     7: 0000000000000001     0 NOTYPE  GLOBAL DEFAULT    1 sym0
</pre>

<pre>
$ objdump -d defsym.o 

defsym.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:	90                   	nop

0000000000000001 &lt;sym0&gt;:
   1:	90                   	nop

0000000000000002 &lt;sym1&gt;:
   2:	90                   	nop
   3:	90                   	nop
   4:	90                   	nop
   5:	90                   	nop

0000000000000006 &lt;sym2&gt;:
   6:	90                   	nop
</pre>

<p> sym0, sym1, sym2 というみっつのシンボルを定義しているプログラムだ。 </p>

<p> これのラベルをダンプすると、 </p>

<pre>
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     4: 0000000000000002     0 NOTYPE  LOCAL  DEFAULT    1 sym1
     5: 0000000000000006     0 NOTYPE  LOCAL  DEFAULT    1 sym2
     6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT    1 _start
     7: 0000000000000001     0 NOTYPE  GLOBAL DEFAULT    1 sym0
</pre>

<p> このようになる。1-3 については、あとのセクションのところで詳しく書く。 0番は…筆者も何か知らない。 </p>

<p> Value のカラムで示される値が、ファイル内でのオフセットだ。sym0,sym1,sym2 のそれぞれのオフセット値を確認してほしい。 </p>

<p> 次にSizeとTypeカラム、シンボルは上のほうで書いたように、デバッグ時等にも使える情報を含んでいる。これもあとでもう少し詳しく説明しよう。 </p>

<p>
  次はBindとVisカラム。プログラムを書いたことのある人なら、「スコープ」の重要性は理解しているだろう。
  オブジェクトファイルにもこのスコープの概念があり、シンボルが見える範囲を制御することができる。
  オブジェクトファイルにもいくつかのスコープ階層がある。
</p>

<ul>
  <li> ローカルシンボル </li>
  <li> グローバルシンボル </li>
  <li> エクスポートシンボル </li>
</ul>

<p>
  ローカルシンボルは、ファイル内でのみ参照可能な定義済みシンボルだ。C言語のstaticが付いたグローバル変数、関数がこれに相当すると思ってもらってよい。
  グローバルシンボルは、逆にファイル外からも参照できる定義済みシンボルで、こちらはC言語でいうとstaticが付かないグローバル変数、関数が相当する。
</p>

<p>
  ローカルシンボルは、別のファイルからは参照できない。
</p>

<p> <a href="link/local_symbol0.s"> link/local_symbol0.s </a> </p>
<pre>
_start:
	mov	$local_symbol, %rax
	mov	$global_symbol, %rax
</pre>

<p> <a href="link/local_symbol1.s"> link/local_symbol1.s </a> </p>
<pre>
	.globl global_symbol

local_symbol:
	nop
global_symbol:
	nop
</pre>

<pre>
$ as local_symbol0.s -o local_symbol0.o
$ as local_symbol1.s -o local_symbol1.o
$ ld local_symbol0.o local_symbol1.o 
/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000400078
local_symbol0.o: In function `_start':
(.text+0x3): undefined reference to `local_symbol'
</pre>

<p>
  local_symbol が local_symbol1.s で定義されているが、定義されていないとエラーが出ていることを確認しよう。
</p>

<p>
  ついでに、_start 見つからないとエラーが出ているのを確認してほしい。
  これまでのアセンブリファイルでは、ファイルの最初に、
</p>

<pre>
  .globl _start
  .globl main
</pre>

<p> などと書いていたことを思い出そう。ようやくこれを説明するときがきた。 </p>

<p> .globl は、アセンブラに対して、指定した定義済みシンボルをグローバルシンボルにしろ、と指示する疑似命令だ。(.globalでもいい) </p>

<p>
  "main" シンボルは、スタートアップルーチンからファイルを超えて参照されるので、グローバルシンボルにしておく必要がある。
  そのため、これまでのアセンブリファイルには、".globl main" を書いていた。
</p>

<p>
  "_start" シンボルの扱いは、通常のシンボルとは少し違うが、
  リンク時の挙動として、「グローバルシンボルの"_start"をプログラムの開始位置とする」と決められている。
  オブジェクトを超えて外部から見えるように扱うので、グローバルシンボルとして扱うほうが自然だろう。
</p>

<p>
  次に、エクスポートシンボルだ。これは、DLL 等の共有ライブラリを作るときなどに使われるシンボルで、
  実行時にもファイルを超えて参照される定義済みシンボルだ。
</p>

<p>
  共有ライブラリを使う場合には、実行時にもファイルを超えて未定義シンボルと定義済みシンボルを結びつけるリンク処理が必要になり、
  そのための情報を残しておく必要がある。
  エクスポートシンボルはそのためのシンボルだ。
</p>

<p>
  Linux では、visibilityという属性(readelf -s で見られる Vis カラム)が、エクスポートシンボルかどうかに影響していて、
  リンク時にエクスポートシンボルを残すと指示した場合に、Vis が DEFAULT のシンボルがエクスポートシンボルになる。
</p>

<p>
  共有ライブラリについては、いくらか書くべきことが多いので、エクスポートシンボルの扱いについてはまたあとで別に書くとしよう。
</p>

<p> あとウィークシンボルというのもあるが、これはLinux(というかELF)固有の概念なので特にここでは書かない。興味がある人は各自で調べてほしい。 </p>

<p> -- </p>

<p> また、シンボル情報はDLLを使わない場合、実行時には必要の無い情報だが、デバッグ時にはいくらか有用な場合があることを覚えておこう。 </p>

<p>
  これまで何度か gdb を使ってプログラムを動かしてきたと思うが、そのときに、数字のアドレスではなく、
  文字列としてのシンボルを扱えていたことを思い出してほしい。
  例えば、"break _start" などとすると、_startシンボルを解決した後のアドレスにブレークポイントを設定できていたはずだ。
</p>

<p>
  デバッガは、デバッグ情報が存在しなかった場合でも、残っているシンボル情報から、なるべくアドレスがわかりやすい値になるように
  最善を尽くす努力をしていて、
</p>

<ul>
  <li> アドレスを表示する場合には、そのアドレス付近に存在するシンボルから、一番それっぽいのを探して表示する </li>
  <li> ユーザがシンボル文字列を入力した場合には、そのシンボルと対応するアドレス値をうまいこと扱う </p>
</ul>

<p> というような挙動をする。 </p>
<p> 一番最初に info registers と打ったときの結果を思い出してほしい。 </p>

<pre>
(gdb) start
Temporary breakpoint 1 at 0x4004d6
Starting program: /mnt/d/wsl/src/pllp/docs/x8664_asm_language/a.out 

Temporary breakpoint 1, 0x00000000004004d6 in main ()
(gdb) info registers
rax            0x4004d6	4195542
rbx            0x0	0
rcx            0x0	0
rdx            0x7ffffffee518	140737488282904
rsi            0x7ffffffee508	140737488282888
rdi            0x1	1
rbp            0x4004e0	0x4004e0 &lt;__libc_csu_init&gt;
rsp            0x7ffffffee428	0x7ffffffee428
r8             0x400550	4195664
r9             0x7fffff410ab0	140737475840688
r10            0x846	2118
r11            0x7fffff050740	140737471907648
r12            0x4003e0	4195296
r13            0x7ffffffee500	140737488282880
r14            0x0	0
r15            0x0	0
rip            0x4004d6	0x4004d6 &lt;main&gt;
eflags         0x246	[ PF ZF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0

</pre>

<p>
  rbp の値に __libc_csu_init という文字列が付いているのがわかるだろう。
  これが gdb が rbp に残っていた値から探してきたシンボルの文字列だ。
</p>

<p>
  __libc_csu_init は、名前からして、libc の C Start Up の init だという推測ができる。
  main に来る前のスタートアップの初期化処理で rbp レジスタに何か値を入れていたのが残っていたのだろう。
</p>

<ul>
  <li> デバッガは値と紐付いたシンボル文字列を探してくるように努力する </li>
  <li> main に来る前にはスタートアップ処理が入る </li>
</ul>

<p>
  という二点を知っておけば、main に来た直後にデバッガで全レジスタを表示したら、スタートアップ処理に関連するシンボルが表示される可能性が高いという
  のは推測できるようになって、この表示は不思議な表示ではなくなったはずだ。
</p>

<h4> リロケーション </h4>

<p class="kokomade"> (ここまで書いた )</p>

<p>
  次に<em>リロケーション</em> だ。<em> リロケーション </em> は、アドレス解決後の値を埋め込む方法を保持する情報だ。
</p>

<p>
  readelfを使えばリロケーションの情報も見ることができる。"-r" で、リロケーション情報を表示だ。
</p>

<p> さきほどの <a href="link/link_label1.s"> link/link_label1.s </a> をアセンブルしたlink_label1.o を見てみよう。 </p>

<pre>
$ readelf -r link_label1.o

Relocation section &39;.rela.text&39; at offset 0xe8 contains 1 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000003  00050000000b R_X86_64_32S      0000000000000000 _start + 0
</pre>

<pre>
$ readelf -s link_label1.o

Symbol table &39;.symtab&39; contains 6 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 
     4: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT    1 label0
     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _start
$
 </pre>

<p>
  "-r" で出したものがリロケーション、"-s" で出したものがシンボルだ。
</p>

<p>
  リロケーションから詳しく見ていこう。
</p>

<p> <a href="link/reloc.s"> link/reloc.s </a> </p>
<pre>
	.globl	_start
_start:
	movl	$ref_32bit, %eax # 32bitラベルを参照
	movw	$ref_16bit, %ax	 # 16bitラベルを参照
	movb	$ref_8bit, %al   # 8bitラベルを参照
	jmp	ref_as_jmp_label # PC 相対アドレスを参照

	movl	$ref_32bit + 32, %eax # オフセット付き

	mov	$60, %rax
	syscall

</pre>


<p> <a href="link/reloc.s"> link/reloc_label.s </a> </p>
<pre>
	.text
	.globl ref_32bit
	.globl ref_16bit
	.globl ref_8bit
	.globl ref_as_jmp_label

	nop
ref_32bit:
	nop
ref_16bit:
	nop
ref_8bit:
	nop
ref_as_jmp_label:
	nop
</pre>

<p>--</p>


<pre>
$ readelf -r reloc.o 

Relocation section '.rela.text' at offset 0x170 contains 5 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000001  00050000000a R_X86_64_32       0000000000000000 ref_32bit + 0
000000000007  00060000000c R_X86_64_16       0000000000000000 ref_16bit + 0
00000000000a  00070000000e R_X86_64_8        0000000000000000 ref_8bit + 0
000000000011  00050000000a R_X86_64_32       0000000000000000 ref_32bit + 20
00000000000c  000800000002 R_X86_64_PC32     0000000000000000 ref_as_jmp_label - 4
</pre>

<pre>
$ objdump -d reloc.o                       # リンク前の逆アセンブル

reloc.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:	b8 00 00 00 00       	mov    $0x0,%eax
   5:	66 b8 00 00          	mov    $0x0,%ax
   9:	b0 00                	mov    $0x0,%al
   b:	e9 00 00 00 00       	jmpq   10 &lt;_start+0x10&gt;
  10:	b8 00 00 00 00       	mov    $0x0,%eax
  15:	48 c7 c0 3c 00 00 00 	mov    $0x3c,%rax
  1c:	0f 05                	syscall 
</pre>

<pre>
$ objdump -dr reloc.o                       # -dr でリロケーションと逆アセンブルを同時に表示

reloc.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:	b8 00 00 00 00       	mov    $0x0,%eax
			1: R_X86_64_32	ref_32bit
   5:	66 b8 00 00          	mov    $0x0,%ax
			7: R_X86_64_16	ref_16bit
   9:	b0 00                	mov    $0x0,%al
			a: R_X86_64_8	ref_8bit
   b:	e9 00 00 00 00       	jmpq   10 &lt;_start+0x10&gt;
			c: R_X86_64_PC32	ref_as_jmp_label-0x4
  10:	b8 00 00 00 00       	mov    $0x0,%eax
			11: R_X86_64_32	ref_32bit+0x20
  15:	48 c7 c0 3c 00 00 00 	mov    $0x3c,%rax
  1c:	0f 05                	syscall 
</pre>


<pre>
$ ld  reloc.o reloc_label.o -Ttext=0x0     # ラベル値を8bit以内にするためtextの位置を0にしておく
$ objdump  -d a.out                        # リンク後の逆アセンブル

a.out:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:	b8 1f 00 00 00       	mov    $0x1f,%eax
   5:	66 b8 20 00          	mov    $0x20,%ax
   9:	b0 21                	mov    $0x21,%al
   b:	e9 12 00 00 00       	jmpq   22 &lt;ref_as_jmp_label&gt;
  10:	b8 3f 00 00 00       	mov    $0x3f,%eax
  15:	48 c7 c0 3c 00 00 00 	mov    $0x3c,%rax
  1c:	0f 05                	syscall 
  1e:	90                   	nop

000000000000001f &lt;ref_32bit&gt;:
  1f:	90                   	nop

0000000000000020 &lt;ref_16bit&gt;:
  20:	90                   	nop

0000000000000021 &lt;ref_8bit&gt;:
  21:	90                   	nop

0000000000000022 &lt;ref_as_jmp_label&gt;:
  22:	90                   	nop
</pre>

<p>--</p>

<pre>
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000001  00050000000a R_X86_64_32       0000000000000000 ref_32bit + 0
</pre>

<p>
  まず、Offset、これは解決した値を埋める位置を示している。最初の mov 命令の32bitオペランドの位置が、
  先頭から1byteのところにあるのを確認しよう。
  これが1byteなので、Offsetは1だ。
</pre>

<pre>
#リンク前
           v ここ(offset=1byte)に解決した32bit値を入れる
   0:	b8 00 00 00 00       	mov    $0x0,%eax

#リンク後
   0:	b8 1f 00 00 00       	mov    $0x1f,%eax
</pre>

<p>
  次に、Info と Type。x86_64 では、 Info の下32bitが Type になり、Type のカラムは、この32bit値を読みやすい形で表示しているだけだ。
  Info の下32bit が、0x0000000a の場合、Type が R_X86_64_32 になる。
</p>

<p>
  Type の解釈方法は、CPUによって異なる。x86_64 の場合は、<a href="https://www.uclibc.org/docs/psABI-x86_64.pdf"> AMD64 ABI </a> に書かれている。
  まあ筆者もこれはちゃんと読んだことはなくて、自分でリンカを作るとかでなければ、/usr/include/elf.h にある定義を見ればよいと思う。
</p>

<p>
  reloc.o に含まれるリロケーションの Type には色々あるのを確認してほしい。シンボルの参照方法は、一種類ではなく、複数ある。
</p>

<pre>
	movl	$ref_32bit, %eax # 32bitラベルを参照
	movw	$ref_16bit, %ax	 # 16bitラベルを参照
</pre>

<ul>
  <li> movl のほうは、ラベル解決後の値を32bit値として、命令のオペランドに埋めてほしい </li>
  <li> movw のほうは、ラベル解決後の値を16bit値として、命令のオペランドに埋めてほしい </li>
</ul>

<p> このふたつでは、命令中のオペランドの書き換えかたが変わるはずだ。ここで、「どうやってオペランドを書き換えるか」を示すのが、リロケーションのTypeだ。</p>

<pre>
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000001  00050000000a R_X86_64_32       0000000000000000 ref_32bit + 0
000000000007  00060000000c R_X86_64_16       0000000000000000 ref_16bit + 0
</pre>

<p> offset=0000000000000001 の 32bit mov のオペランドのリロケーションと、offset=0000000000000007 の 16bit mov のオペランドのリロケーションで Type が違う点、解決後の値の埋めかたが変わっている点を確認してほしい。 </p>


<pre>
#asm
	movl	$ref_32bit, %eax # 32bitラベルを参照
	movw	$ref_16bit, %ax	 # 16bitラベルを参照

#リンク前
   0:	b8 00 00 00 00       	mov    $0x0,%eax
   5:	66 b8 00 00          	mov    $0x0,%ax

#リンク後
   0:	b8 1f 00 00 00       	mov    $0x1f,%eax   # ラベル ref_32bit を解決した値 1f を 32bit値として入れる
   5:	66 b8 20 00          	mov    $0x20,%ax    # ラベル ref_16bit を解決した値 20 を 16bit値として入れる
</pre>

<p> また、同じサイズのリロケーションでもTypeが異なる場合がある。 </p>

<pre>
	movl	$ref_32bit, %eax # 32bitラベルを参照
	jmp	ref_as_jmp_label # PC 相対アドレスを参照
</pre>

<pre>
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000001  00050000000a R_X86_64_32       0000000000000000 ref_32bit + 0
00000000000c  000800000002 R_X86_64_PC32     0000000000000000 ref_as_jmp_label - 4
</pre>

<p>
  x86_64 機械語では、分岐命令のアドレスは、分岐命令の直後のアドレスからの相対値になる。
  上の jmp 命令で、ref_as_jmp_label ラベルが、解決されたあと、その値がそのまま埋められると、jmp 命令は正しく機能しない。
  リンカは、ref_as_jmp_label の解決後、jmp 命令の次の命令が置かれたアドレスとの相対値を埋める必要がある。
</p>

<pre>
# asm
	jmp	ref_as_jmp_label # PC 相対アドレスを参照

# リンク前
   b:	e9 00 00 00 00       	jmpq   10 &lt;_start+0x10&gt;

# リンク後
   b:	e9 12 00 00 00       	jmpq   22 &lt;ref_as_jmp_label&gt;
  10:	b8 3f 00 00 00       	mov    $0x3f,%eax
   (.. 略 ..)
0000000000000022 &lt;ref_as_jmp_label&gt;:
  22:	90                   	nop

</pre>

<p>
  jmp 命令の次の命令のアドレスが0x10、
  ref_as_jmp_label の解決後の値が 0x22、その差は  +0x12 となって、jmp 命令のオペランドには +0x12 が埋められることを確認してほしい。
</p>

  <h3> セクション </h3>
  <h3> 実行ファイル、セグメント </h3>

  <h3> ELF </h3>

  <h3> ldscript </h3>

  <h3> address relaxation </h3>

  <h3> ローダ </h3>

  <h3> PE/COFF </h3>

<p>
  オブジェクトファイルのフォーマットは、OS ごとに異なるが、
  リロケーション、シンボル、セクションといった概念は、どのオブジェクトでも大きく変わることはない。
  ここでは、Windowsで使われているCOFFについて簡単に説明する。
  これまで見てきた概念は、特定の実装に依存せず広く利用されているのを確認してほしい。
</p>

<p> (ちなみに、OSXでは、Mach-O というまた別のフォーマットが採用されている。筆者はあまり詳しくないので、OSXユーザは各自で調べてください) </p>

<p>
  Microsoft の開発環境をインストールして cl.exe などのツールが動くようにしてほしい。
  cl.exe が動くようになっていれば、dumpbin.exe というコマンドも使えるようになっているはずだ。
  dumpbin.exe は、readelf のようにオブジェクトの内容を表示するコマンドがある。これで色々見ていってみよう。
</p>



<p> <a href="index.html"> 戻る </a> </p>



</body>
</html>