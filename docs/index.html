<html>
<head>
  <title>実践的低レベルプログラミング</title>
</head>
<style>
  pre { border: solid 1px }
  em { font-weight: bold; color: red }
</style>

<body>

<h1> 実践的低レベルプログラミング </h1>

<h1> はじめに </h1>

<p> 学校で習わないが(習う学校もある)、現実に必要になるプログラミング技術に、低レベルプログラミングなどと呼ばれるものがある </p>

<p>
厳密な定義は聞いたことがないし、おそらく存在しないとは思うが、大体のみんなの共通認識として、
「高級プログラミング言語を使わないプログラムを書き、OSで抽象化されないデバイスの機能を使う」といったような認識があると思う。
</p>

<p>
  筆者の経験から言わせてもらうならば、低レベルプログラミングに関する知識は、プログラミングにおいてあらゆる場面で、常に、少しずつ役立てられる知識だと言えると思う。</p>
<p>
  普段はRubyやPHPなどを書いてる人であったとしても、メモリが足りなくなった場合や、デバッガを使っている場合、性能が足りなくなった場合など、
  厳しい環境におかれた時に低レベルプログラミングに関する知識が必ず役に立つ場面が来ると信じている。
</p>

<p>
  また、役に立つかどうかは置いておいても、「プログラムはどのように動いているのか」を知ることは、知的好奇心を満たし、
  その知識を駆使すれば、コンピュータの挙動を手中に収めた全能感を楽しむことができることだろう。
</p>

<p>
多くのプログラム初心者が、
「#include &lt;stdio.h&gt; ってなになのか？」「何故 print "Hello World" というプログラムを実行すると、画面に"Hello World"と出るのか？」
と、いった点について、多かれ少なかれ疑問を持ちながら、モヤモヤとした気持ちでプログラムを書いたことがあるはずだ。
</p>

<p>
  しかし、残念ながら、これらに関する知識は体系立てられているとは言えず、
  また、低レベルプログラミングがターゲットとする領域では、
  アドホックな方法で、場当たり的に実装されたものがそのままデファクトスタンダードになってしまう例が数多くあり、
  なんらかの一般的な理論を勉強するよりは、実装ごとの事情を勉強する必要があるのが現実である。
</p>


<p>
  それでも、現実にある多くの事情、デバイス、実装などを眺めていれば、そこはかとなく存在する一般的な概念を読みとることができるはずで、
  それらの多くを実際に経験した筆者は、おそらく多くの人より、なんらかの普遍的な知識を獲得しているだろうという自信はある。
</p>

<p>
  この文章は、筆者が書ける限りの、色々なデバイスの色々な事情について、書けるかぎり書いていこうというものである。
  普遍的な知識を表現することは難しいが、色々なレイヤの事情を通して、なんらかの共通する概念を習得する人がひとりでも増えれば幸いである。
</p>

<h1> 環境 </h1>

<p> なんらかの方法で Linux、GCC、binutils の環境を用意することを強くお勧めする。実機でもVMでもWSLでも構わない。(もしかすると実機でしかできないこともやるかもしれないが) </p>

<p>
  Windowsにも、優れた開発環境はあるが、少し道を踏みはずした低レベルプログラミングをする場合、ぱぱっと色々なコマンドを組みあわせて変なことができる
  Linux環境のほうがかなり使いやすい。道をはずしたプログラミングをするなら、Linux環境に慣れておくにこしたことはないと思う。
</p>

<p>
  また、場合によってはARMなどの、PC以外の環境にも触れたいと思っているが、Linuxならば、その場合にもインターフェースが共通して使えるので、心強い。
</p>

<p>
  巨大なライブラリなどは必要ない。C言語で書いた Hello World がコンパイルできる程度の環境があれば十分である。ついでにgdbも使えるようになっているとよい。
</p>

<p>
  PC以外に、Raspberry Pi、Zybo などを使っていくかもしれない。手元にある人は使ってみてほしい。
</p>


<h1> アセンブリ、C言語、リンカ、ローダ、機械語、ABI </h1>
 <p>
   アセンブリ言語はご存知だろうか？ご存知のかたは、どの程度ご存知であろうか。
   もし、あなたが、共有ライブラリロード時のリロケーションの処理が何なのか説明できる程度に、色々なことを知っているならば、もう、この章は飛ばしてもらってかまわない。(というかそもそもこの文章読む意味あるか？)
</p>

<p>
  低レベルプログラミングにおいて、機械語は第一級言語だと言っていい。機械語に関する理解なく、低レベルプログラミングにチャレンジするのは、筆や鉛筆等を持たないで絵を描くのと似たようなものだ。
</p>

<p>
  この章の目的は
</p>

<ul>
  <li> アセンブリ言語と機械語の違いを確実に理解すること </li>
  <li> C言語がコンパイルされるとどのようなアセンブリになるか、おおまかに把握すること </li>
</ul>

<p>
  の二点だ。
</p>

<p>
  できる限り、わかりやすい説明を試みるが、かなり重いテーマなので、筆者の説明不足などにより、全てを正しく理解するのは難しいかもしれない。
  その場合でも、次からの章を断片的に理解することはできるので、よくわからなければ、次の章へ進んでもらってもかまわない。
  この文章全体を読み終えるくらいに、第一章が理解できるぐらいのペースでもよいと思う。
</p>

<p>
  また、C言語への理解がまだ浅い人は、別のC言語の書籍、解説ページを用意して、そちらと交互に読んでいくものよいかもしれない。
  ポインタなどがわからないという人も、その背後にある機械語を理解すれば、いくらか理解しやすくなることもある。C言語の文法などは基本的に説明しないので、
  よくわからなければ、C言語の本に戻っていただいてもかまわない。多分、両方をちょっとずつ理解していくのがいいと思う。
</p>

<h2> x86_64 プログラミング入門 </h2>

<p>好きなエディタを開いて、add.s というテキストファイルを作り、中に以下のように書く</p>

<p> <a href="1/add.s"> 1/add.s </a> </p>

<pre>
	.globl	main
main:
	add $1, %rax
        ret

</pre>

<p> 続いて、gcc を使って、これを実行ファイルに変換する。 </p>

<pre>
 $ gcc add.s
 $ ls
 add.s
 a.out
</pre>

<p> 間違いがなければ、同じディレクトリに、a.out という実行ファイルができているはずだ。 </p>

<p> 次に、gdb に a.out を指定して起動する。(デバッガは、CPUやメモリの状態を調べるのに、非常に有用なツールである。必要な使いかたは都度説明するが、可能ならば色々な使いかたを知っておくことをおすすめする) </p>

<pre>
 $ gdb a.out
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./a.out...done.
(gdb) 

</pre>

<p> gdb のプロンプトが出るはずだ。このプロンプトに対して、 </p>

<ul>
  <li> start </li>
  <li> info registers </li>
</ul>

<p>と、打ちこんでみよう。</p>

<pre>
(gdb) start
Temporary breakpoint 1 at 0x4004d6
Starting program: /mnt/d/wsl/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x00000000004004d6 in main ()
(gdb) info registers
rax            0x4004d6	4195542
rbx            0x0	0
rcx            0x0	0
rdx            0x7ffffffee518	140737488282904
rsi            0x7ffffffee508	140737488282888
rdi            0x1	1
rbp            0x4004e0	0x4004e0 &lt;__libc_csu_init&gt;
rsp            0x7ffffffee428	0x7ffffffee428
r8             0x400550	4195664
r9             0x7fffff410ab0	140737475840688
r10            0x846	2118
r11            0x7fffff050740	140737471907648
r12            0x4003e0	4195296
r13            0x7ffffffee500	140737488282880
r14            0x0	0
r15            0x0	0
rip            0x4004d6	0x4004d6 &lt;main&gt;
eflags         0x246	[ PF ZF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0

</pre>

<p> このような出力がされると思う。(実際の値は、OSやライブラリによって異なるため、同じ値ではなくてもよいです) </p>

<p>
現代の多くのCPUは、<em>レジスタ</em> と呼ばれる、
ごく少量のメモリ ———メモリってなんだ？という疑問を忘れないで！それについてはそのうち説明しよう！とりあえずここはデータを保存する領域と思ってもらいたい——— を、搭載している。
</p>

<p>
gdb の info registers というコマンドは、その<em>レジスタ</em>を表示するコマンドである。
</p>

<p>
info registers の出力を見て、以下のような情報を読み取ってほしい。
</p>

<pre>

                        値の10進表現
rax            0x4004d6	4195542
レジスタ名     値の16進表現

</pre>

<ul>
  <li> このPCに使われているCPUには、rax, rbx, rcx, ... fs, gs という名前のレジスタが搭載されている </li>
  <li> raxレジスタに保持されている値は、10進表現で4195542、16進表現で0x4004d6 </li>
  <li> rbxレジスタに保持されている値は、0 </li>
  <li> rcx ... </li>
  <li> ... </li>
  <li> rbp レジスタに保持されている値は… &lt;__libc_cs_init&gt; … え、何これ？ </li>
  <li> rip レジスタに保持されている値は… &lt;main&gt; … main関数か？？？ </li>
  <li> eflags レジスタの PF ZF IF って…何？ </li>
</ul>

<p>
  レジスタには、いくつか種類があり、レジスタによって使える場面に制限がある。
  現代の一般的なCPUのレジスタは、以下のように分類される
<p/>


<ul>
  <li> 汎用レジスタ : データを保持する。x86_64では、64bit値を保持できる。色々な命令を使って操作ができる </li>
  <li> プログラムカウンタ : 現在実行している命令のアドレスを保持する。これもx86_64では64bit。値を操作するのに特殊な命令が必要 </li>
  <li> フラグレジスタ(またはステータスレジスタ) : 演算結果のうち、データではない結果を保持する。例えば、足し算の結果が、64bit値に収まらない場合、それを示す値が入れられる </li>
  <li> 浮動小数レジスタ : 浮動小数演算のデータを保持する。x86_64 上の gdb の info registers では表示されていない </li>
</ul>

<p> gdb の info registers 表示されているレジスタの分類は、以下のとおりである。 </p>

<ul>
  <li>rax : 汎用レジスタ </li>
  <li>rbx : 汎用レジスタ </li>
  <li>rcx : 汎用レジスタ </li>
  <li>rdx : 汎用レジスタ </li>
  <li>rsi : 汎用レジスタ </li>
  <li>rdi : 汎用レジスタ </li>
  <li>rbp : 汎用レジスタ </li>
  <li>rsp : 汎用レジスタ兼スタックポインタ (！？) </li>
  <li>r8  : 汎用レジスタ </li>
  <li>r9  : 汎用レジスタ </li>
  <li>r9  : 汎用レジスタ </li>
  <li>r10 : 汎用レジスタ </li>
  <li>r11 : 汎用レジスタ </li>
  <li>r12 : 汎用レジスタ </li>
  <li>r13 : 汎用レジスタ </li>
  <li>r14 : 汎用レジスタ </li>
  <li>r15 : 汎用レジスタ </li>
  <li>rip : プログラムカウンタ </li>
  <li>eflags : フラグレジスタ </li>
  <li> cs : セグメントレジスタ (！？) </li>
  <li> ss : セグメントレジスタ  </li>
  <li> ds : セグメントレジスタ  </li>
  <li> es : セグメントレジスタ  </li>
  <li> fs : セグメントレジスタ  </li>
  <li> gs : セグメントレジスタ  </li>
</ul>

<p> と、なっている。え…スタックポインタとかセグメントレジスタって何…？ </p>

<p> x86_64 は、PCが誕生する(より以前？)から存在したCPUの仕様をいくらかひきずっており、現代のCPUでは見られない *生きた化石* のようなレジスタが見られるのが特徴である。このへんの話は、話がずれるので、そのうち書くことにする。とりあえずセグメントレジスタは忘れてもらって構わない。一時期は消滅したスタックポインタが、aarch64 で復活したのは興味深い点ではある。</p>

<p> まず最初は、汎用レジスタだ。汎用レジスタは、多くの命令の入力、出力用の領域として使うことができ、プログラマから見たとき、一番目にすることが多いはずだ。</p>

<p> 最初に書いたプログラムをもう一度見てもらいたい </p>
<pre>
	.globl	main
main:
	add $1, %rax
        ret

</pre>

<p>まず、.globl 、 次に main: と、あるが、これはあとのリンカのところで説明しよう。 </p>

<p> 次に来るのが、 add $1, &percnt;rax という行だ。 <p>

<p> これは、「アセンブリ言語でのadd命令」を書いた行で、意味は、 <p>


<pre>
	add $1, %rax
                rax レジスタに対して、
            1を
        足す
</pre>

<p> と、なる。 </p>

<p> 一般的なCPUでは、多くの命令は、以下のような形式をしている </p>

<pre>
        instruction    operand0, operand1

- instruction : 命令の名前、何をするかを指示する
- operand0 : 0番目のオペランド、どのレジスタに対して命令を実行するかを指示する
- operand1 : 1番目のオペランド、命令によっては、複数のレジスタを入出力にとることがあり、その場合は、コンマで区切って 1番目、2番目のオペランド、というように指示していく
</pre>

<p> だがしかし！悲しいかな、x86_64 の Linux では、アセンブリの表記方法が一般的ではなく、

<pre>
        instruction    operand1, operand0
</pre>

<p> というように、operand1 と operand0 の順序が入れかわってしまう(AT&amp;T記法)。これは、Intel のマニュアルの表記(Intel記法)とは異なっており、完全な初心者殺しである。 </p>

<p> 標準にあわせるオプションもあるが、gdbなど各種ツールの出力がAT&amp;T記法なので慣れるしかない。ここ以降、出現する命令の表記では、operand1, operand0 の順番になっており、Intel のマニュアルとは順序が異なっているという点を頭に入れて読んでほしい。 </p>

<p> さて、それでは、add 命令の挙動を見てみよう。さきほどの gdb のコンソールに戻ろう(コンソールをなくしてしまった人は、もう一度gdbを起動して、start を実行しよう) </p>

<p> まず、gdbのコンソール に disassemble と入力する </p>

<pre>
(gdb) disassemble
Dump of assembler code for function main:
=> 0x00000000004004d6 &lt;+0&gt;:	add    $0x1,%rax
   0x00000000004004da &lt;+4&gt;:	retq   
   0x00000000004004db &lt;+5&gt;:	nopl   0x0(%rax,%rax,1)
End of assembler dump.
</pre>

<p> このような文字が表示されるはずだ。disassemble コマンドは、現在実行中の関数に含まれる命令を表示するコマンドで、今は、プログラムの開始地点、main関数を実行しようというところなので、main 関数に含まれる命令列を表示している。 </p>

<p>
  いや、"main関数"について説明が足りてない、これは、あとでリンクのところで説明するが、一応簡単に説明しておこう。
</p>

<p> 最初に書いたプログラムを見てほしい。 </p>

<pre>
main:
	add $1, %rax
        ret
</pre>

<p>
 "main:" という行を最初に書いたはずだ。C言語を書いたことがある人なら、main関数は見たことあるだろう。
 この、"main:" という行は、<em>ラベル</em> と呼ばれる、C言語の関数にかなり近い物体を作るように指示する行で、 このように書くことで、
 デバッガから見たときに、ここに、C言語のmain関数のようなものが存在するように見えるのである。
 (実際に、gdbは、 "Dump of assembler code for function main:"、"main関数のアセンブラコードのダンプ" と言っている点に注目しよう)
</p>


<p> gdb には、一命令だけ、命令を実行する、stepi (step instruction)というコマンドがあるこれを実行しよう。そして、一命令実行したら、もう一度 info register として、レジスタを表示しよう。 </p>

<p> 次のようになるはずだ。 </p>

<pre>
(gdb) info register
rax            0x4004d6	4195542
rbx            0x0	0
rcx            0x0	0
rdx            0x7ffffffee518	140737488282904
rsi            0x7ffffffee508	140737488282888
rdi            0x1	1
rbp            0x4004e0	0x4004e0 &lt;__libc_csu_init&gt;
rsp            0x7ffffffee428	0x7ffffffee428
r8             0x400550	4195664
r9             0x7fffff410ab0	140737475840688
r10            0x846	2118
r11            0x7fffff050740	140737471907648
r12            0x4003e0	4195296
r13            0x7ffffffee500	140737488282880
r14            0x0	0
r15            0x0	0
rip            0x4004d6	0x4004d6 &lt;main&gt;
eflags         0x246	[ PF ZF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
(gdb) stepi 
0x00000000004004da in main ()
(gdb) info register
rax            0x4004d7	4195543
rbx            0x0	0
rcx            0x0	0
rdx            0x7ffffffee518	140737488282904
rsi            0x7ffffffee508	140737488282888
rdi            0x1	1
rbp            0x4004e0	0x4004e0 &lt;__libc_csu_init&gt;
rsp            0x7ffffffee428	0x7ffffffee428
r8             0x400550	4195664
r9             0x7fffff410ab0	140737475840688
r10            0x846	2118
r11            0x7fffff050740	140737471907648
r12            0x4003e0	4195296
r13            0x7ffffffee500	140737488282880
r14            0x0	0
r15            0x0	0
rip            0x4004da	0x4004da &lt;main+4&gt;
eflags         0x206	[ PF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
(gdb) 
</pre>

<p> rax レジスタの値に注目してほしい </p>

<pre>
(gdb) info register
rax            0x4004d6	4195542
...(略)...
(gdb) stepi 
0x00000000004004da in main ()
(gdb) info register
rax            0x4004d7	4195543
...(略)...
</pre>

<p> stepi を実行したあとに、rax の値が1増えているのが確認できる。これで、add $1, rax を実行すると、 </p>



 <h2> C言語とアセンブリ </h2>
  <h3> ABI, Calling Convention (呼び出し規約) </h3>
 <h2> リンカ </h2>

  <p>
    筆者が常々思っていることのひとつに、「C言語に関する書籍は、リンカの説明をおざなりにしすぎだ」というのがある。
  </p>
  <p>
    多くのC言語の書籍は、
  </p>
  <ol>
    <li> コンパイラがソースコードをアセンブリコードに変換します </li>
    <li> アセンブラがアセンブリコードを機械語に変換します </li>
    <li> リンカが機械語をリンクして実行ファイルが作られます </li>
  </ol>

  <p>
    と、いう解説がなされがちである。この説明を見たら、多くの人が、「え、リンクってなんですか？」と、思うに違いない。
  </p>
  <p>
    アセンブラには、「人間が読めるニーモニックと、機械が読める機械語を変換する」みたいな、最低限の説明が付くものの、
    リンカの説明は「リンクをします」のひとことだけである！
  </p>

  <p>
    ここでは、いつも雑な説明をされがちな、リンカについて説明をしていきたいと思う。
  </p>

  <p>
    C言語の言語仕様には、明示的にリンクについて書かれてはいないものの、
    extern 指定子など、言語仕様の一部に、リンクの処理を無視して説明できない仕様を含んでいるのは間違いない。
  </p>
  <p>
    リンカに対する理解なくして、C言語の理解はありえないのだ！
  </p>

  <h3> ELF </h3>
  <h3> ldscript </h3>
  <h3> リロケーション </h3>
  <h3> ローダ </h3>
 <h2> おまけ : printf </h2>
 <h2> おまけ : shellcode </h2>

<h1> Linux デバイスドライバ </h1>

<p>
  低レベルプログラミングを習得するためにLinux デバイスドライバについて学習するのは良い方法かもしれない。
</p>

<p>
  普段は、様々な問題からプログラマを守ってくれるOSではあるが、
  道を外したプログラミングをする場合、このOSの保護が邪魔になる場合がある。
</p>

<p>
  OSの保護を回避する手段として、「OSなし(ベアメタル)プログラミング」という世界がある。
  これは、非常に楽しいプログラミングではあるが、場合によってはprintfで数値を画面に出力したり、mallocでメモリを確保するだけでも
  かなりの苦労を伴う手法である。
</p>

<p>
  そこで、別の方法として、Linuxデバイスドライバを書くという方法もある。
</p>

<p>
  Linuxデバイスドライバまわりの開発環境は、非常によく整備されていて、
  printf ぐらい気軽に文字列を出力できるし、mallocぐらい気軽にメモリを割り当てられるし、
  プログラムにミスがあってエラーが出れば、エラーが発生した箇所を教えてくれる機能が付いている。
  「Linuxデバイスドライバ」という、優れた書籍があるのも嬉しい点だ。
</p>

<p>
  また、Linuxデバイスドライバについて深く学ぶと、演習で使うようなtoy OSにはない、
  現実世界で広く使われるOSに必要なものを肌で感じられるようになるというメリットもある
  (例えば、toyOSではCPUの速度に迫るような高速な周辺デバイスのことは考えられていないなど)。
  あと現実的な話をしてしまうと、Linuxドライバを書いてほしい/修正してほしいという仕事は世の中にたくさんあり、
  Linuxドライバが書けるようになっていると、職にあぶれないという点も見逃せない。
</p>

<p>
  この章では、本文書の説明で使える程度の範囲内で、Linuxデバイスドライバの書きかたについて説明していく。
  より詳しい使いかたに興味がある人は、書籍や、Linuxのソースコードを参照してほしい。
</p>

  <h2> GPIOデバイスドライバ (みんな大好きLチカプログラミング) </h2>

<h1> UART による通信 </h1>

<h1> ベアメタルプログラミング </h1>

  <h2> ブートとは </h2>

  <h2> SPI flash </h2>

  <h2> DRAMコントローラ </h2>

  <h2> ファームウェア、BIOS、UEFI </h2>

  <h2> おまけ : デバイスツリー </h2>

<h1> OSを支える技術 </h1>

 <h2> メモリ保護 </h2>
  <h3> 仮想化 </h3>

 <h2> 割り込み </h2>
  <h3> SMP </h3>

<h1> デバッガ </h1>

<h1> DMA </h1>

<h1> キャッシュ </h1>

<h1> ネットワーク </h1>

  <h2> TCP/IP </h2>
  <h2> イーサネット </h2>
  <h2> Infiniband </h2>

<h1> i2c </h1>

<h1> PCI Express </h1>

<h1> GPU </h1>

<h1> USB </h1>

<h1> ストレージ </h1>

 <h2> SATA </h2>
 <h2> NVMe </h2>
 <h2> ファイルシステム </h2>

<h1> FPGA </h1>

<h1> RTC </h1>

<h1> ヒープ、malloc、GC </h1>

<h1> チューニング </h1>

<h1> コンパイラ/インタプリタ </h1>

<h1> 低レベルプログラミングに関する書籍 </h1>

</body>
</html>
