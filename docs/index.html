<html>
<head>
  <meta charset="utf-8"/>
  <title>実践的低レベルプログラミング</title>
</head>
<style>
  pre { border: solid 1px }
  em { font-weight: bold; color: red }
  table,td,th { border: solid 1px; }
  #kokomade { color: green; }
</style>

<body>

<h1> 実践的低レベルプログラミング </h1>

<h1> はじめに </h1>

<p> 学校で習わないが(習う学校もある)、現実に必要になるプログラミング技術に、低レベルプログラミングなどと呼ばれるものがある </p>

<p>
厳密な定義は聞いたことがないし、おそらく存在しないとは思うが、大体のみんなの共通認識として、
「高級プログラミング言語を使わないプログラムを書き、OSで抽象化されないデバイスの機能を使う」といったような認識があると思う。
</p>

<p>
  筆者の経験から言わせてもらうならば、低レベルプログラミングに関する知識は、プログラミングにおいてあらゆる場面で、常に、少しずつ役立てられる知識だと言えると思う。</p>
<p>
  普段はRubyやPHPなどを書いてる人であったとしても、メモリが足りなくなった場合や、デバッガを使っている場合、性能が足りなくなった場合など、
  厳しい環境におかれた時に低レベルプログラミングに関する知識が必ず役に立つ場面が来ると信じている。
</p>

<p>
  また、役に立つかどうかは置いておいても、「プログラムはどのように動いているのか」を知ることは、知的好奇心を満たし、
  その知識を駆使すれば、コンピュータの挙動を手中に収めた全能感を楽しむことができることだろう。
</p>

<p>
多くのプログラム初心者が、
「#include &lt;stdio.h&gt; ってなになのか？」「何故 print "Hello World" というプログラムを実行すると、画面に"Hello World"と出るのか？」
と、いった点について、多かれ少なかれ疑問を持ちながら、モヤモヤとした気持ちでプログラムを書いたことがあるはずだ。
</p>

<p>
  しかし、残念ながら、これらに関する知識は体系立てられているとは言えず、
  また、低レベルプログラミングがターゲットとする領域では、
  アドホックな方法で、場当たり的に実装されたものがそのままデファクトスタンダードになってしまう例が数多くあり、
  なんらかの一般的な理論を勉強するよりは、実装ごとの事情を勉強する必要があるのが現実である。
</p>


<p>
  それでも、現実にある多くの事情、デバイス、実装などを眺めていれば、そこはかとなく存在する一般的な概念を読みとることができるはずで、
  それらの多くを実際に経験した筆者は、おそらく多くの人より、なんらかの普遍的な知識を獲得しているだろうという自信はある。
</p>

<p>
  この文章は、筆者が書ける限りの、色々なデバイスの色々な事情について、書けるかぎり書いていこうというものである。
  普遍的な知識を表現することは難しいが、色々なレイヤの事情を通して、なんらかの共通する概念を習得する人がひとりでも増えれば幸いである。
</p>

<h1> 環境 </h1>

<p> なんらかの方法で Linux、GCC、binutils の環境を用意することを強くお勧めする。実機でもVMでもWSLでも構わない。(もしかすると実機でしかできないこともやるかもしれないが) </p>

<p>
  Windowsにも、優れた開発環境はあるが、少し道を踏みはずした低レベルプログラミングをする場合、ぱぱっと色々なコマンドを組みあわせて変なことができる
  Linux環境のほうがかなり使いやすい。道をはずしたプログラミングをするなら、Linux環境に慣れておくにこしたことはないと思う。
</p>

<p>
  また、場合によってはARMなどの、PC以外の環境にも触れたいと思っているが、Linuxならば、その場合にもインターフェースが共通して使えるので、心強い。
</p>

<p>
  巨大なライブラリなどは必要ない。C言語で書いた Hello World がコンパイルできる程度の環境があれば十分である。ついでにgdbも使えるようになっているとよい。
</p>

<p>
  PC以外に、Raspberry Pi、Zybo などを使っていくかもしれない。手元にある人は使ってみてほしい。
</p>


<h1> アセンブリ、C言語、リンカ、ローダ、機械語、ABI </h1>
 <p>
   アセンブリ言語はご存知だろうか？ご存知のかたは、どの程度ご存知であろうか。
   もし、あなたが、共有ライブラリロード時のリロケーションの処理が何なのか説明できる程度に、色々なことを知っているならば、もう、この章は飛ばしてもらってかまわない。(というかそもそもこの文章読む意味あるか？)
</p>

<p>
  低レベルプログラミングにおいて、機械語は第一級言語だと言っていい。機械語に関する理解なく、低レベルプログラミングにチャレンジするのは、筆や鉛筆等を持たないで絵を描くのと似たようなものだ。
</p>

<p>
  この章の目的は
</p>

<ul>
  <li> アセンブリ言語と機械語の違いを確実に理解すること </li>
  <li> C言語がコンパイルされるとどのようなアセンブリになるか、おおまかに把握すること </li>
</ul>

<p>
  の二点だ。
</p>

<p>
  できる限り、わかりやすい説明を試みるが、かなり重いテーマなので、筆者の説明不足などにより、全てを正しく理解するのは難しいかもしれない。
  その場合でも、次からの章を断片的に理解することはできるので、よくわからなければ、次の章へ進んでもらってもかまわない。
  この文章全体を読み終えるくらいに、第一章が理解できるぐらいのペースでもよいと思う。
</p>

<p>
  また、C言語への理解がまだ浅い人は、別のC言語の書籍、解説ページを用意して、そちらと交互に読んでいくものよいかもしれない。
  ポインタなどがわからないという人も、その背後にある機械語を理解すれば、いくらか理解しやすくなることもある。C言語の文法などは基本的に説明しないので、
  よくわからなければ、C言語の本に戻っていただいてもかまわない。多分、両方をちょっとずつ理解していくのがいいと思う。
</p>

<h2> x86_64 プログラミング入門 </h2>

<p>好きなエディタを開いて、add.s というテキストファイルを作り、中に以下のように書く</p>

<p> <a href="1/add.s"> 1/add.s </a> </p>

<pre>
	.globl	main
main:
	add $1, %rax
        ret

</pre>

<p> 続いて、gcc を使って、これを実行ファイルに変換する。 </p>

<pre>
 $ gcc add.s
 $ ls
 add.s
 a.out
</pre>

<p> 間違いがなければ、同じディレクトリに、a.out という実行ファイルができているはずだ。 </p>

<p> 次に、gdb に a.out を指定して起動する。(デバッガは、CPUやメモリの状態を調べるのに、非常に有用なツールである。必要な使いかたは都度説明するが、可能ならば色々な使いかたを知っておくことをおすすめする) </p>

<pre>
 $ gdb a.out
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./a.out...done.
(gdb) 

</pre>

<p> gdb のプロンプトが出るはずだ。このプロンプトに対して、 </p>

<ul>
  <li> start </li>
  <li> info registers </li>
</ul>

<p>と、打ちこんでみよう。</p>

<pre>
(gdb) start
Temporary breakpoint 1 at 0x4004d6
Starting program: /mnt/d/wsl/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x00000000004004d6 in main ()
(gdb) info registers
rax            0x4004d6	4195542
rbx            0x0	0
rcx            0x0	0
rdx            0x7ffffffee518	140737488282904
rsi            0x7ffffffee508	140737488282888
rdi            0x1	1
rbp            0x4004e0	0x4004e0 &lt;__libc_csu_init&gt;
rsp            0x7ffffffee428	0x7ffffffee428
r8             0x400550	4195664
r9             0x7fffff410ab0	140737475840688
r10            0x846	2118
r11            0x7fffff050740	140737471907648
r12            0x4003e0	4195296
r13            0x7ffffffee500	140737488282880
r14            0x0	0
r15            0x0	0
rip            0x4004d6	0x4004d6 &lt;main&gt;
eflags         0x246	[ PF ZF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0

</pre>

<p> このような出力がされると思う。(実際の値は、OSやライブラリによって異なるため、同じ値ではなくてもよいです) </p>

<p>
現代の多くのCPUは、<em>レジスタ</em> と呼ばれる、
ごく少量のメモリ ———メモリってなんだ？という疑問を忘れないで！それについてはそのうち説明しよう！とりあえずここはデータを保存する領域と思ってもらいたい——— を、搭載している。
</p>

<p>
gdb の info registers というコマンドは、その<em>レジスタ</em>を表示するコマンドである。
</p>

<p>
info registers の出力を見て、以下のような情報を読み取ってほしい。
</p>

<pre>

                        値の10進表現
rax            0x4004d6	4195542
レジスタ名     値の16進表現

</pre>

<ul>
  <li> このPCに使われているCPUには、rax, rbx, rcx, ... fs, gs という名前のレジスタが搭載されている </li>
  <li> raxレジスタに保持されている値は、10進表現で4195542、16進表現で0x4004d6 </li>
  <li> rbxレジスタに保持されている値は、0 </li>
  <li> rcx ... </li>
  <li> ... </li>
  <li> rbp レジスタに保持されている値は… &lt;__libc_cs_init&gt; … え、何これ？ </li>
  <li> rip レジスタに保持されている値は… &lt;main&gt; … main関数か？？？ </li>
  <li> eflags レジスタの PF ZF IF って…何？ </li>
</ul>

<p>
  レジスタには、いくつか種類があり、レジスタによって使える場面に制限がある。
  現代の一般的なCPUのレジスタは、以下のように分類される
<p/>


<ul>
  <li> 汎用レジスタ : データを保持する。x86_64では、64bit値を保持できる。色々な命令を使って操作ができる </li>
  <li> プログラムカウンタ (またはインストラクションポインタ) : 現在実行している命令のアドレスを保持する。これもx86_64では64bit。値を操作するのに特殊な命令が必要 </li>
  <li> フラグレジスタ(またはステータスレジスタ) : 演算結果のうち、データではない結果を保持する。例えば、足し算の結果が、64bit値に収まらない場合、それを示す値が入れられる </li>
  <li> 浮動小数レジスタ : 浮動小数演算のデータを保持する。x86_64 上の gdb の info registers では表示されていない </li>
</ul>

<p> gdb の info registers 表示されているレジスタの分類は、以下のとおりである。 </p>

<ul>
  <li>rax : 汎用レジスタ </li>
  <li>rbx : 汎用レジスタ </li>
  <li>rcx : 汎用レジスタ </li>
  <li>rdx : 汎用レジスタ </li>
  <li>rsi : 汎用レジスタ </li>
  <li>rdi : 汎用レジスタ </li>
  <li>rbp : 汎用レジスタ </li>
  <li>rsp : 汎用レジスタ兼スタックポインタ (！？) </li>
  <li>r8  : 汎用レジスタ </li>
  <li>r9  : 汎用レジスタ </li>
  <li>r9  : 汎用レジスタ </li>
  <li>r10 : 汎用レジスタ </li>
  <li>r11 : 汎用レジスタ </li>
  <li>r12 : 汎用レジスタ </li>
  <li>r13 : 汎用レジスタ </li>
  <li>r14 : 汎用レジスタ </li>
  <li>r15 : 汎用レジスタ </li>
  <li>rip : プログラムカウンタ </li>
  <li>eflags : フラグレジスタ </li>
  <li> cs : セグメントレジスタ (！？) </li>
  <li> ss : セグメントレジスタ  </li>
  <li> ds : セグメントレジスタ  </li>
  <li> es : セグメントレジスタ  </li>
  <li> fs : セグメントレジスタ  </li>
  <li> gs : セグメントレジスタ  </li>
</ul>

<p> と、なっている。え…スタックポインタとかセグメントレジスタって何…？ </p>

<p> x86_64 は、PCが誕生する(より以前？)から存在したCPUの仕様をいくらかひきずっており、現代のCPUでは見られない *生きた化石* のようなレジスタが見られるのが特徴である。このへんの話は、話がずれるので、そのうち書くことにする。とりあえずセグメントレジスタは忘れてもらって構わない。一時期は消滅したスタックポインタが、aarch64 で復活したのは興味深い点ではある。</p>

<p> まず最初は、汎用レジスタだ。汎用レジスタは、多くの命令の入力、出力用の領域として使うことができ、プログラマから見たとき、一番目にすることが多いはずだ。</p>

<p> 最初に書いたプログラムをもう一度見てもらいたい </p>
<pre>
	.globl	main
main:
	add $1, %rax
        ret

</pre>

<p>まず、.globl 、 次に main: と、あるが、これはあとのリンカのところで説明しよう。 </p>

<p> 次に来るのが、 add $1, &percnt;rax という行だ。 <p>

<p> これは、「アセンブリ言語でのadd命令」を書いた行で、意味は、 <p>


<pre>
	add $1, %rax
                rax レジスタに対して、
            1を
        足す
</pre>

<p> と、なる。 </p>

<p> 一般的なCPUでは、多くの命令は、以下のような形式をしている </p>

<pre>
        instruction    operand0, operand1

- instruction : 命令の名前、何をするかを指示する
- operand0 : 0番目のオペランド、どのレジスタに対して命令を実行するかを指示する
- operand1 : 1番目のオペランド、命令によっては、複数のレジスタを入出力にとることがあり、その場合は、コンマで区切って 1番目、2番目のオペランド、というように指示していく
</pre>

<p> だがしかし！悲しいかな、x86_64 の Linux では、アセンブリの表記方法が一般的ではなく、

<pre>
        instruction    operand1, operand0
</pre>

<p> というように、operand1 と operand0 の順序が入れかわってしまう(AT&amp;T記法)。これは、Intel のマニュアルの表記(Intel記法)とは異なっており、完全な初心者殺しである。 </p>

<p> 標準にあわせるオプションもあるが、gdbなど各種ツールの出力がAT&amp;T記法なので慣れるしかない。ここ以降、出現する命令の表記では、operand1, operand0 の順番になっており、Intel のマニュアルとは順序が異なっているという点を頭に入れて読んでほしい。 </p>

<p> さて、それでは、add 命令の挙動を見てみよう。さきほどの gdb のコンソールに戻ろう(gdbのコンソールをなくしてしまった人は、もう一度gdbを起動して、start を実行しよう) </p>

<p> まず、gdbのコンソール に disassemble と入力する </p>

<pre>
(gdb) disassemble
Dump of assembler code for function main:
=&gt; 0x00000000004004d6 &lt;+0&gt;:	add    $0x1,%rax
   0x00000000004004da &lt;+4&gt;:	retq   
   0x00000000004004db &lt;+5&gt;:	nopl   0x0(%rax,%rax,1)
End of assembler dump.
</pre>

<p> このような文字が表示されるはずだ。"disassemble" コマンドは、現在停止中の関数に含まれる命令を表示するコマンドで、今は、プログラムの開始地点、main関数を実行しようというところで停止しているので、main 関数に含まれる命令列を表示している。 </p>

<p>
  いや、"main関数"について説明が足りてない、これは、詳しくはあとでリンクのところで説明するが、一応簡単に説明しておこう。
</p>

<p> 最初に書いたプログラムを見てほしい。 </p>

<pre>
main:
	add $1, %rax
        ret
</pre>

<p>
 "main:" という行を最初に書いたはずだ。C言語を書いたことがある人なら、main関数は見たことあるだろう。
 この、"main:" という行は、<em>ラベル</em> と呼ばれる、C言語の関数にかなり近い物体を作るように指示する行で、 このように<em>ラベル</em>を書くことで、
 デバッガから見たときに、ここに、C言語のmain関数のようなものが存在するように見えるのである。
 (実際に、gdbは、 "Dump of assembler code for function main:"、"main関数のアセンブラコードのダンプ" と言っている点に注目しよう)
</p>

<p>
  さて、最初にgdbを起動したときに、"start" コマンドを実行したことを思い出してほしい。
</p>

<p>
  "start" コマンドは、「プログラムを起動し、main関数の先頭でプログラムを一旦停止する」というコマンドである。
  そのため、"start"コマンドを実行した直後に、"disassemble" コマンドを実行すると、main関数に含まれる命令列がダンプされるのだ。
</p>

<p>disassemble の出力を見てみよう。</p>

<pre>
(gdb) disassemble
Dump of assembler code for function main:
=&gt; 0x00000000004004d6 &lt;+0&gt;:	add    $0x1,%rax
   0x00000000004004da &lt;+4&gt;:	retq   
   0x00000000004004db &lt;+5&gt;:	nopl   0x0(%rax,%rax,1)
End of assembler dump.
</pre>

<pre>
=&gt; 0x00000000004004d6 &lt;+0&gt;:	add    $0x1,%rax
</pre>

<p> の、ように、=&gt; で行が矢印で指されているのがわかると思う。これが、現在プログラムが停止している位置を示している。 </p>

<p>
  add.s では、main 関数の先頭に、add 命令を書いたので、これを実行しようという直前で停止しているわけだ。
  では、ここで指されている命令を実行してみよう。
</p>

<p> gdb には、一命令だけ、命令を実行する、stepi (step instruction)というコマンドがあるこれを実行しよう。そして、一命令実行したら、もう一度 info register として、レジスタを表示しよう。 </p>

<p> 次のようになるはずだ。 </p>

<pre>
(gdb) info register
rax            0x4004d6	4195542
rbx            0x0	0
rcx            0x0	0
rdx            0x7ffffffee518	140737488282904
rsi            0x7ffffffee508	140737488282888
rdi            0x1	1
rbp            0x4004e0	0x4004e0 &lt;__libc_csu_init&gt;
rsp            0x7ffffffee428	0x7ffffffee428
r8             0x400550	4195664
r9             0x7fffff410ab0	140737475840688
r10            0x846	2118
r11            0x7fffff050740	140737471907648
r12            0x4003e0	4195296
r13            0x7ffffffee500	140737488282880
r14            0x0	0
r15            0x0	0
rip            0x4004d6	0x4004d6 &lt;main&gt;
eflags         0x246	[ PF ZF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
(gdb) stepi 
0x00000000004004da in main ()
(gdb) info register
rax            0x4004d7	4195543
rbx            0x0	0
rcx            0x0	0
rdx            0x7ffffffee518	140737488282904
rsi            0x7ffffffee508	140737488282888
rdi            0x1	1
rbp            0x4004e0	0x4004e0 &lt;__libc_csu_init&gt;
rsp            0x7ffffffee428	0x7ffffffee428
r8             0x400550	4195664
r9             0x7fffff410ab0	140737475840688
r10            0x846	2118
r11            0x7fffff050740	140737471907648
r12            0x4003e0	4195296
r13            0x7ffffffee500	140737488282880
r14            0x0	0
r15            0x0	0
rip            0x4004da	0x4004da &lt;main+4&gt;
eflags         0x206	[ PF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
(gdb) 
</pre>

<p> rax レジスタの値に注目してほしい </p>

<pre>
(gdb) info register
rax            0x4004d6	4195542
...(略)...
(gdb) stepi 
0x00000000004004da in main ()
(gdb) info register
rax            0x4004d7	4195543
...(略)...
</pre>

<p>
  stepi を実行したあとに、rax の値が1増えているのが確認できる。これが、add 命令の効果である。add $1, %rax をという命令を実行すると、
  rax レジスタに入っている命令が、1増えるのだ。
</p>

<p> ここまで確認したら、一旦gdbを終了しよう。gdb を終了するのは、quit コマンドだ。</p>

<pre>
(gdb) quit
A debugging session is active.

	Inferior 1 [process 1665] will be killed.

Quit anyway? (y or n) y
 $ 
</pre>

<p>
  「プログラムが実行中だが終了してよいか？」と聞かれるが、今は重要なプログラムを実行しているわけではないので、y でいい。
  ここで add 命令の次に書いた ret は何？と、疑問に思っている方もいるかもしれない。それについては、あとのOSインターフェースのところで解説する。
</p>

<p>
  いくつか解説をはさんでしまったので、ここまでの流れをざっともう一度流しておこう
</p>

<ul>
  <li> start : プログラムを開始してmain関数の先頭で処理を止める </li>
  <li> info registers : レジスタの値を表示 </li>
  <li> disassemble : 現在実行中の関数に含まれる命令を表示 </li>
  <li> stepi : 一命令実行する </li>
  <li> quit : gdb を終了 </li>
</ul>


<pre>
$ gdb a.out
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;
and &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-linux-gnu&quot;.
Type &quot;show configuration&quot; for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type &quot;help&quot;.
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
Reading symbols from a.out...(no debugging symbols found)...done.
(gdb) start
Temporary breakpoint 1 at 0x4004d6
Starting program: /mnt/d/wsl/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x00000000004004d6 in main ()
(gdb) disassemble
Dump of assembler code for function main:
=&gt; 0x00000000004004d6 &lt;+0&gt;:	add    $0x1,%rax
   0x00000000004004da &lt;+4&gt;:	retq   
   0x00000000004004db &lt;+5&gt;:	nopl   0x0(%rax,%rax,1)
End of assembler dump.
(gdb) info registers
rax            0x4004d6	4195542
rbx            0x0	0
rcx            0x0	0
rdx            0x7ffffffee518	140737488282904
rsi            0x7ffffffee508	140737488282888
rdi            0x1	1
rbp            0x4004e0	0x4004e0 &lt;__libc_csu_init&gt;
rsp            0x7ffffffee428	0x7ffffffee428
r8             0x400550	4195664
r9             0x7fffff410ab0	140737475840688
r10            0x846	2118
r11            0x7fffff050740	140737471907648
r12            0x4003e0	4195296
r13            0x7ffffffee500	140737488282880
r14            0x0	0
r15            0x0	0
rip            0x4004d6	0x4004d6 &lt;main&gt;
eflags         0x246	[ PF ZF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
(gdb) stepi
0x00000000004004da in main ()
(gdb) info registers
rax            0x4004d7	4195543
rbx            0x0	0
rcx            0x0	0
rdx            0x7ffffffee518	140737488282904
rsi            0x7ffffffee508	140737488282888
rdi            0x1	1
rbp            0x4004e0	0x4004e0 &lt;__libc_csu_init&gt;
rsp            0x7ffffffee428	0x7ffffffee428
r8             0x400550	4195664
r9             0x7fffff410ab0	140737475840688
r10            0x846	2118
r11            0x7fffff050740	140737471907648
r12            0x4003e0	4195296
r13            0x7ffffffee500	140737488282880
r14            0x0	0
r15            0x0	0
rip            0x4004da	0x4004da &lt;main+4&gt;
eflags         0x206	[ PF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
(gdb) quit
A debugging session is active.

	Inferior 1 [process 1770] will be killed.

Quit anyway? (y or n) y
</pre>

<p> もうひとつ、よく使う gdb のコマンドを紹介しておこう。print コマンドだ。 </p>

<pre>
(gdb) start
Temporary breakpoint 1 at 0x4004d6
Starting program: /mnt/d/wsl/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x00000000004004d6 in main ()
(gdb) print $rax
$1 = 4195542
(gdb) print /x $rax
$2 = 0x4004d6
(gdb) print 45 * 4
$3 = 180
(gdb) print /x 255
$5 = 0xff
(gdb) print $r8
$7 = 4195664
(gdb) print $r9
$8 = 140737475840688
(gdb) print $ds
$9 = 0
(gdb) print $cs
$10 = 51
(gdb) print $rax + 512
$11 = 4196054
</pre>

<p>
  print コマンドは、コマンドに与えた式の値を表示してくれる。"/x" を付けると、値を16進で表示だ。
  print $rax + 512 のように、頭に'$' を付けて、レジスタ名を書くと、式の中にレジスタの値を入れることができる。
</p>


<p> さて、それでは gdb で命令を実行して、結果を表示する方法は解説したので、いくつか基本的な命令を説明しておこう。 </p>

<p> レジスタに値を設定する、mov 命令。 </p>

<p> <a href="1/mov.s"> 1/mov.s </a> </p>

<pre>
	.globl	main
main:
	mov $1, %rax
        ret

</pre>

<pre>
(gdb) start
Temporary breakpoint 1 at 0x4004d6
Starting program: /mnt/d/wsl/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x00000000004004d6 in main ()
(gdb) disassemble
Dump of assembler code for function main:
=&gt; 0x00000000004004d6 &lt;+0&gt;:	mov    $0x1,%rax
   0x00000000004004dd &lt;+7&gt;:	retq   
   0x00000000004004de &lt;+8&gt;:	xchg   %ax,%ax
End of assembler dump.
(gdb) p $rax
$1 = 4195542
(gdb) stepi
0x00000000004004dd in main ()
(gdb) disassemble
Dump of assembler code for function main:
   0x00000000004004d6 &lt;+0&gt;:	mov    $0x1,%rax
=&gt; 0x00000000004004dd &lt;+7&gt;:	retq   
   0x00000000004004de &lt;+8&gt;:	xchg   %ax,%ax
End of assembler dump.
(gdb) p $rax
$2 = 1
</pre>

<p> rax の値が 1 になる。 </p>

<p>
  p コマンドは、print の略で、gdb では、よく使うコマンドは、省略できるという機能がある。 printはよく使うので、p 一文字で実行できる。
  同じように、info registers も、"i r" で実行可能だ。慣れてくると使ってみるのもよいかもしれない。
</p>

<p> 多くの演算は、レジスタ間で演算することが可能だ。 </p>

<p> <a href="1/add2.s">1/add2.s</a> </p>

<pre>
	.globl	main
main:
	mov $1, %rax
	mov $2, %r8
	add %r8, %rax
	ret
</pre>

<p>とすると、r8 レジスタの値を、raxレジスタに加算できる。 </p>

<pre> 
(gdb) start
Temporary breakpoint 1 at 0x4004d6
Starting program: /mnt/d/wsl/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x00000000004004d6 in main ()
(gdb) stepi
0x00000000004004dd in main ()
(gdb) stepi
0x00000000004004e4 in main ()
(gdb) p $rax
$1 = 1
(gdb) p $r8
$2 = 2
(gdb) disassemble
Dump of assembler code for function main:
   0x00000000004004d6 &lt;+0&gt;:	mov    $0x1,%rax
   0x00000000004004dd &lt;+7&gt;:	mov    $0x2,%r8
=&gt; 0x00000000004004e4 &lt;+14&gt;:	add    %r8,%rax
   0x00000000004004e7 &lt;+17&gt;:	retq   
   0x00000000004004e8 &lt;+18&gt;:	nopl   0x0(%rax,%rax,1)
End of assembler dump.
(gdb) stepi
0x00000000004004e7 in main ()
(gdb) p $rax
$3 = 3
(gdb) p $r8
$4 = 2
(gdb) 
</pre>

<p> rax レジスタの値が、1 + 2 = 3 になっていることを確認しよう。 </p>

<p> subで減算、imul で乗算、and,or,xor で bitwise and, or, xor だ。</p>

<p> <a href="1/sub.s">1/sub.s</a> </p>

<pre>
	.globl	main
main:
	mov $1, %rax
	mov $2, %r8
	sub %r8, %rax

	mov $3, %rax
	mov $4, %r8
	imul %r8, %rax

	mov $0xaa, %rax
	mov $0x0f, %r8
	and %r8, %rax

	mov $0xaa, %rax
	mov $0x0f, %r8
	or %r8, %rax

	mov $0xaa, %rax
	mov $0x0f, %r8
	xor %r8, %rax

	ret
</pre>


<pre>
Temporary breakpoint 2, 0x00000000004004d6 in main ()
(gdb) stepi 3
0x00000000004004e7 in main ()
(gdb) p $rax
$5 = -1
(gdb) stepi 3
0x00000000004004f9 in main ()
(gdb) p $rax
$6 = 12
(gdb) stepi 3
0x000000000040050a in main ()
(gdb) p /x $rax
$7 = 0xa
(gdb) stepi 3
0x000000000040051b in main ()
(gdb) p /x $rax
$8 = 0xaf
(gdb) stepi 3
0x000000000040052c in main ()
(gdb) p /x $rax
$11 = 0xa5
(gdb) 
</pre>

<p> gdb の stepi コマンドは、引数に数字を渡すと、その回数だけ繰り返してくれる。stepi 3 の意味は、命令を3個実行だ。 </p>


<h3> メインメモリ、ロード、ストア命令 </h3>

<p>
  x86_64 では、さきほど見たように、汎用レジスタが16個あった。汎用レジスタは一個8byteあるので、16個あれば、128byteのデータを保持できることになる。
  128byte というのは、本当に小さなサイズだ。画像で言うと、8x8ピクセルの画像も保持できないし、今書いてるこの文章も扱えないほど、ほんとうに小さなサイズだ。

  たった128byteのデータでできることなんてほとんど何もない。月へ行くことだって難しいだろう。
</p>

<p>
  今のコンピュータのように、大きな写真や、動画を見たり編集したりするには、128byteよりも、もっともっと大きなデータを扱える必要がある。
  現代の一般的なコンピュータは、この大きなデータを保持するために、「メインメモリ」、日本の情報の教科書的に言うと、「主記憶装置」と呼ばれるものが付いている。
</p>

<p>
  メインメモリは、データを保存するためのデバイスで、保存したデータを<em>アドレス</em> と呼ばれる整数値で指定し、次のふたつの操作をすることができる。
</p>

<ul>
  <li> ストア (保存、書き込み、store、writeなどとも言う) : <em>アドレス</em> で指定した箇所にバイトデータを保存する </li>
  <li> ロード (読み込み、load, readなどとも言う) : <em>アドレス</em> で指定した箇所に保存されているバイトデータを取り出す </li>
</ul>

<p> (TODO:図を入れたい) </p>

<p> 例えば、次のような操作が可能だ </p>

<ol>
  <li> アドレス 16 番に、データ 0xcc をストア </li>
  <li> アドレス 20 番に、データ 0x88 をストア </li>
  <li> アドレス 16 番からロード、 データ 0xcc を取り出すことができる </li>
  <li> アドレス 20 番からロード、 データ 0x88 を取り出すことができる </li>
</ol>

<p> 各アドレスによって識別できるデータは、完全に独立していて、 </p>

<ol>
  <li> アドレス 16 番に、データ 0xcc をストア </li>
  <li> アドレス 20 番に、データ 0x88 をストア </li>
  <li> アドレス 20 番からロード、 データ 0x88 を取り出すことができる </li>
  <li> アドレス 16 番からロード、 データ 0xcc を取り出すことができる </li>
</ol>

<p> のように、アドレス毎に、最後にストアしたデータが読めるようになっている。 </p>

<p> また、ロードする操作では、データは変わらず、何度ロードしても最後にストアしたデータが読める </p>

<ol>
  <li> アドレス 20 番に、データ 0x88 をストア </li>
  <li> アドレス 20 番からロード、 データ 0x88 を取り出すことができる </li>
  <li> アドレス 20 番からロード、 データ 0x88 を取り出すことができる </li>
  <li> アドレス 20 番からロード、 データ 0x88 を取り出すことができる </li>
  <li> アドレス 20 番からロード、 データ 0x88 を取り出すことができる </li>
  <li> アドレス 20 番に、データ 0xcc をストア </li>
  <li> アドレス 20 番からロード、 データ 0xcc を取り出すことができる </li>
</ol>

<p> 
  "メイン"メモリ ("主"記憶装置) は、"メイン" ("主")と呼ばれるだけあって、コンピュータを使うときに、レジスタの次によく使われる記憶用デバイスだ。
  メインメモリはCPUの外側にあるのだが、よく使うデバイスなので、メインメモリを操作するための専用の命令が、CPUの中に用意されている。
</p>

<p>
  その専用命令が、<em>ロード命令</em>と<em>ストア命令</em> だ。どのぐらいよく使うかというと、add 命令と同じか、それ以上の頻度で使われる命令だ。
</p>

<p>
  (実際には、この説明は正確ではない。正しい解説はもう少しあとで書く)
</p>

<p>
  <em>ロード命令</em> は、メインメモリにアドレスで識別されるデータを要求し、得られたデータをレジスタに格納する命令で、
  <em>ストア命令</em> は、メインメモリにレジスタに含まれるデータを、指定したアドレスに保存するように、メインメモリに要求する命令だ。
</p>

<p> x86_64 の AT&amp;T 記法では、それぞれ次のように書く </p>

<ul>
  <li> ロード命令 : mov アドレス, レジスタ : (メインメモリの中のデータのうち、アドレスで識別されるデータを取得して、レジスタに保存する) </li>
  <li> ストア命令 : mov レジスタ, アドレス : (レジスタに含まれるデータを、メインメモリの中のアドレスで識別される領域に保存する) </li>
</ul>

<p> 見てわかるかもしれないが、x86_64 では、ロード命令も、ストア命令も両方とも、"mov命令" だ。ニーモニックとしては区別されず、オペランドの順序が変わっているだけである </p>

<p> 
  これはややこしいかもしれないが、そうなってしまっているので仕方ない。
  筆者はロード命令とストア命令は別物だと理解したほうが理解しやすいと思っているので、mov 命令を見たときは、
</p>

<ul>
  <li> レジスタに数値データ(即値という)を直接入れる mov命令 (上のほうで使っていたmovだ) </li>
  <li> レジスタのデータを別のレジスタにコピーする mov命令 (あ、説明してない。あとで上に追加しておこう) </li>
  <li> ロード mov命令 </li>
  <li> ストア mov命令 </li>
</ul>

<p> の、どれになるかをきちんと区別するのをお勧めしたい。区別の仕方を覚えよう </p>

<ul>
  <li> 即値mov は、即値に '$' が付き、それに&percnt;からはじまるレジスタ名が続く : " mov $15, &percnt;rax" </li>
  <li> レジスタ間コピーは、両方のオペランドに&percnt;からはじまるレジスタ名が入る : " mov &percnt;rax, &percnt;rdx" </li>
  <li> ロードは最初のオペランドに、'$'が付かない数字、もしくは丸括弧'()'でくくられたレジスタ名が入る : "mov (&percnt;rax), %rdx " or "mov 15, &percnt;rax </li>
  <li> ストアは二番目のオペランドに、'$'が付かない数字、もしくは丸括弧'()'でくくられたレジスタ名が入る : "mov %rdx, (&percnt;rax)" or "mov &percnt;rax, 15</li>
</ul>

<p> (実際は、もう少し話がややこしい。これはx86_64機械語のところで説明する) </p>

<p> ともかく、言いたかったこととしては、mov命令を使うと、メインメモリの中のアドレスで識別できる領域に対して、データを保存したり、保存したデータを取り出したりできるということだ。 </p>

<p> それでは、早速、このmov命令の挙動を見てみよう。 </p>

<p> <a href="1/load.s"> 1/load.s </a> </p>
<pre>
	.globl	main
main:
	mov $99, %rax
	mov %rax,0  		# アドレス0で識別される領域に、raxの値(99)を保存する
	mov 0, %r8 		# アドレス0で識別される領域から、値を取り出し、その値をr8に格納する
	ret
</pre>

<p> これをさきほどと同じように、gcc で a.out に変換し、それを gdb で見てみよう </p>

<pre>
 $ gcc load.s
 $ gdb a.out
GNU gdb (GDB) 8.2
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-pc-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from a.out...(no debugging symbols found)...done.
(gdb) start
Temporary breakpoint 1 at 0x401106
Starting program: /home/w0/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x0000000000401106 in main ()
(gdb) stepi
0x000000000040110d in main ()
(gdb) stepi

Program received signal SIGSEGV, Segmentation fault.
0x000000000040110d in main ()
(gdb) stepi

Program terminated with signal SIGSEGV, Segmentation fault.
The program no longer exists.
(gdb) 

</pre> 

<p> おや…何かがおかしい…プログラムが終了してしまった。 </p>

<p>
  これは、OSの<em>メモリ保護</em>機能が働いた結果だ。
</p>

<p>
  メインメモリは、各コンピュータに一個か、数個ぐらいしかない。
  その一個のメインメモリの上で、たくさんのプログラムが動いている。
  (例えば、あなたは、この文章をブラウザで見ながら、エディタでプログラムを編集し、gccやgdbを起動している)
  一個のメインメモリを、複数のプログラムで共有しているわけだ。
</p>

<p>
  何の仕組みもなく、一個のメモリを複数のプログラムで共有すると、他のプログラムのデータが読み書きできるので、あまり良くない。
  他人が動かしたプログラムのデータが読めるのはセキュリティ的によくないし、
  一個のプログラムの小さなミスがシステム全体を止めてしまう可能性があるのは、色々問題があるし使いづらいだろう。
</p>

<p>
  これを防ぐために、一般的なOSには、メモリを保護する機能が付いている。
  このメモリ保護の仕組みは、低レベルプログラミングをする上で避けて通れない道なので、あとで詳しく書こう。
  とりあえず、今はOSにはメモリを保護する仕組みがあって、メインメモリはいつでも自由に使えるわけではないという点だけ覚えておいてほしい。
</p>

<p>
  では、どうするか。
  メモリ保護機能のあるOSには、<em>メモリ割り当て(memory allocation)</em>のインターフェースが用意されており、
  そのインターフェースを使うことで、メインメモリの一部を、自由に使えるメモリとしてOSから割り当ててもらうことができる。
</p>

<p>
  メモリを割り当てる方法は、いくつかあるが、一番簡単な方法は、単にプログラムを起動するだけだ。
</p>

<p>
  OSはプログラムを起動するように指示されると、起動するプログラムに必要なメモリを割り当ててから、プログラムの起動を行う。
  いわゆる実行ファイル(Windowsのexe等や、さっきあなたが作ったa.out)には、この、起動時に必要なメモリサイズを示す情報が含まれており、OSはその情報を見ることで、
  プログラムが使うメモリサイズを判断している。
</p>

<p>
  これはリンカのところでもう少し詳しく説明するが、簡単に見ておこう。Linux では、 readelf というコマンドを、-l を付けて実行することで、
  実行ファイルが使うメモリサイズを知ることができる。
</p>

<pre>
$ gcc add.s
$ readelf -l a.out

Elf ファイルタイプは DYN (共有オブジェクトファイル) です
Entry point 0x1020
There are 11 program headers, starting at offset 64

プログラムヘッダ:
  タイプ        オフセット          仮想Addr           物理Addr
            ファイルサイズ        メモリサイズ         フラグ 整列
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x0000000000000268 0x0000000000000268  R      0x8
  INTERP         0x00000000000002a8 0x00000000000002a8 0x00000000000002a8
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000528 0x0000000000000528  R      0x1000
  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                 0x00000000000001a5 0x00000000000001a5  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                 0x00000000000000b8 0x00000000000000b8  R      0x1000
  LOAD           0x0000000000002e28 0x0000000000003e28 0x0000000000003e28
                 0x0000000000000200 0x0000000000000208  RW     0x1000
  DYNAMIC        0x0000000000002e38 0x0000000000003e38 0x0000000000003e38
                 0x00000000000001a0 0x00000000000001a0  RW     0x8
  NOTE           0x00000000000002c4 0x00000000000002c4 0x00000000000002c4
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_EH_FRAME   0x0000000000002004 0x0000000000002004 0x0000000000002004
                 0x0000000000000024 0x0000000000000024  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RWE    0x10
  GNU_RELRO      0x0000000000002e28 0x0000000000003e28 0x0000000000003e28
                 0x00000000000001d8 0x00000000000001d8  R      0x1

 セグメントマッピングへのセクション:
  セグメントセクション...
   00     
   01     .interp 
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn 
   03     .init .text .fini 
   04     .rodata .eh_frame_hdr .eh_frame 
   05     .init_array .fini_array .dynamic .got .got.plt .data .bss 
   06     .dynamic 
   07     .note.ABI-tag .note.gnu.build-id 
   08     .eh_frame_hdr 
   09     
   10     .init_array .fini_array .dynamic .got 
</pre>

<p> 以下の部分に注目しよう </p>

<pre>
  タイプ        オフセット          仮想Addr           物理Addr
            ファイルサイズ        メモリサイズ         フラグ 整列
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x0000000000000268 0x0000000000000268  R      0x8
  INTERP         0x00000000000002a8 0x00000000000002a8 0x00000000000002a8
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000528 0x0000000000000528  R      0x1000
  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                 0x00000000000001a5 0x00000000000001a5  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                 0x00000000000000b8 0x00000000000000b8  R      0x1000
  LOAD           0x0000000000002e28 0x0000000000003e28 0x0000000000003e28
                 0x0000000000000200 0x0000000000000208  RW     0x1000
</pre>

<p> PHDR, INTERP は、また説明が難しいので飛ばすとして、重要なのは、 "LOAD" と書かれている箇所だ。 </p>

<p> "LOAD" は、プログラムを実行するときに使うメモリについての情報を格納した領域で、</p>

<pre>
  LOAD           0x0000000000002e28 0x0000000000003e28 0x0000000000003e28
                 0x0000000000000200 0x0000000000000208  RW     0x1000
</pre>

<p> これは簡単にいうと「実行ファイルの 0x2e28 の位置にあるデータを、メモリ0x3e28 に 0x200 byte 分コピー、領域として、0x208 byte分確保しておく」という意味だ。 </p>

<p> OSは、プログラム実行時に、この情報を見て、必要なメモリの確保を行ってからプログラムを起動してくれる。 </p>

<p>
  ただ、これは、まだ少し説明が正しくなくて…これも今は説明するのが難しいので説明はあとにするが…
  gcc を使うときに、以下のように、"-static -no-pie" を付けてコンパイルすると  この説明と正しく一致するようになる。
</p>

<pre>
$ gcc -static -no-pie add.s
~/src/pllp/docs/1 $ readelf -l a.out

Elf ファイルタイプは EXEC (実行可能ファイル) です
Entry point 0x401a30
There are 8 program headers, starting at offset 64

プログラムヘッダ:
  タイプ        オフセット          仮想Addr           物理Addr
            ファイルサイズ        メモリサイズ         フラグ 整列
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000470 0x0000000000000470  R      0x1000
  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                 0x000000000007c681 0x000000000007c681  R E    0x1000
  LOAD           0x000000000007e000 0x000000000047e000 0x000000000047e000
                 0x00000000000235f0 0x00000000000235f0  R      0x1000
  LOAD           0x00000000000a20a0 0x00000000004a30a0 0x00000000004a30a0
                 0x00000000000051f0 0x0000000000006940  RW     0x1000
  NOTE           0x0000000000000200 0x0000000000400200 0x0000000000400200
                 0x0000000000000044 0x0000000000000044  R      0x4
  TLS            0x00000000000a20a0 0x00000000004a30a0 0x00000000004a30a0
                 0x0000000000000020 0x0000000000000060  R      0x8
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RWE    0x10
  GNU_RELRO      0x00000000000a20a0 0x00000000004a30a0 0x00000000004a30a0
                 0x0000000000002f60 0x0000000000002f60  R      0x1

 セグメントマッピングへのセクション:
  セグメントセクション...
   00     .note.ABI-tag .note.gnu.build-id .rela.plt 
   01     .init .plt .text __libc_freeres_fn .fini 
   02     .rodata .eh_frame .gcc_except_table 
   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data __libc_subfreeres __libc_IO_vtables __libc_atexit .bss __libc_freeres_ptrs 
   04     .note.ABI-tag .note.gnu.build-id 
   05     .tdata .tbss 
   06     
   07     .tdata .init_array .fini_array .data.rel.ro .got 
</pre>

<p>
  説明をもう少し単純にするために、これに加えて、gcc のオプションに "-Tbss=0x800000" を付けよう。
  こうすることで、OSに対して "自由に読み書きできるメインメモリをアドレス0x800000に割り当ててからプログラムを起動してください" と指示できる実行ファイルができあがる。
</p>

<pre>
$ gcc -static -no-pie -Tbss=0x800000 add.s
$ ./a.out 
$ readelf -l a.out

Elf ファイルタイプは EXEC (実行可能ファイル) です
Entry point 0x401a30
There are 10 program headers, starting at offset 64

プログラムヘッダ:
  タイプ        オフセット          仮想Addr           物理Addr
            ファイルサイズ        メモリサイズ         フラグ 整列
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000004e0 0x00000000000004e0  R      0x1000
  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                 0x000000000007c681 0x000000000007c681  R E    0x1000
  LOAD           0x000000000007e000 0x000000000047e000 0x000000000047e000
                 0x00000000000235f0 0x00000000000235f0  R      0x1000
  LOAD           0x00000000000a20a0 0x00000000004a30a0 0x00000000004a30a0
                 0x00000000000051f0 0x00000000000051f0  RW     0x1000
  LOAD           0x00000000000a8000 0x0000000000800000 0x0000000000800000
                 0x0000000000000000 0x0000000000001740  RW     0x1000
  NOTE           0x0000000000000270 0x0000000000400270 0x0000000000400270
                 0x0000000000000020 0x0000000000000020  R      0x4
  NOTE           0x0000000000000290 0x0000000000400290 0x0000000000400290
                 0x0000000000000024 0x0000000000000024  R      0x4
  TLS            0x00000000000a20a0 0x00000000004a30a0 0x00000000004a30a0
                 0x0000000000000020 0x0000000000000060  R      0x8
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RWE    0x10
  GNU_RELRO      0x00000000000a20a0 0x00000000004a30a0 0x00000000004a30a0
                 0x0000000000002f60 0x0000000000002f60  R      0x1

 セグメントマッピングへのセクション:
  セグメントセクション...
   00     .note.ABI-tag .note.gnu.build-id .rela.plt 
   01     .init .plt .text __libc_freeres_fn .fini 
   02     .rodata .eh_frame .gcc_except_table 
   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data __libc_subfreeres __libc_IO_vtables __libc_atexit 
   04     .bss __libc_freeres_ptrs 
   05     .note.ABI-tag 
   06     .note.gnu.build-id 
   07     .tdata .tbss 
   08     
   09     .tdata .init_array .fini_array .data.rel.ro .got 
</pre>

<p> 以下の部分を見てみよう </p>

<pre>
  LOAD           0x00000000000a8000 0x0000000000800000 0x0000000000800000
                 0x0000000000000000 0x0000000000001740  RW     0x1000
</pre>

<p> アドレス 0x800000 に 0x1740 byte 分のメモリを割り当てるように指示する情報が作られているのが確認できるはずだ。(0x1740byte という値はどこから来たんだ？これもあとで説明しよう！あとで説明することが多い！) </p>

<p> <a href="1/load-v2.s"> 1/load-v2.s </a> </p>
<pre>
	# gcc -static -no-pie -Tbss=0x800000 add.s のようにビルドすれば、0x800000 のアドレスに
	# メインメモリがOSから割り当てられた状態でプログラムが起動する実行ファイルを作ることができる

	.globl	main
main:
	mov $99, %rax
	mov %rax,0x800000 # アドレス0x800000で識別される領域に、raxの値(99)を保存する
	mov 0x800000, %r8 # アドレス0x800000で識別される領域から、値を取り出し、その値をr8に格納する
	ret
</pre>

<p> このプログラムをgdbで起動して見てみよう </p>

<pre>
(gdb) start
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Temporary breakpoint 2 at 0x401b55
Starting program: /home/w0/src/pllp/docs/1/a.out 

Temporary breakpoint 2, 0x0000000000401b55 in main ()
(gdb) stepi
0x0000000000401b5c in main ()
(gdb) x/g 0x800000
0x800000 &lt;completed.6735&gt;:	0
(gdb) p /x $rax
$2 = 0x99
(gdb) disassemble
Dump of assembler code for function main:
   0x0000000000401b55 &lt;+0&gt;:	mov    $0x99,%rax
=&gt; 0x0000000000401b5c &lt;+7&gt;:	mov    %rax,0x800000
   0x0000000000401b64 &lt;+15&gt;:	mov    0x800000,%r8
   0x0000000000401b6c &lt;+23&gt;:	retq   
   0x0000000000401b6d &lt;+24&gt;:	nopl   (%rax)
End of assembler dump.
(gdb) stepi
0x0000000000401b64 in main ()
(gdb) x/g 0x800000
0x800000 &lt;completed.6735&gt;:	0x0000000000000099
(gdb) disassemble
Dump of assembler code for function main:
   0x0000000000401b55 &lt;+0&gt;:	mov    $0x99,%rax
   0x0000000000401b5c &lt;+7&gt;:	mov    %rax,0x800000
=&gt; 0x0000000000401b64 &lt;+15&gt;:	mov    0x800000,%r8
   0x0000000000401b6c &lt;+23&gt;:	retq   
   0x0000000000401b6d &lt;+24&gt;:	nopl   (%rax)
End of assembler dump.
(gdb) stepi
0x0000000000401b6c in main ()
(gdb) p /x $r8
$3 = 0x99
</pre>

<p> また新しいgdbコマンドを使ってしまった。ここで使っているのは、"x" コマンドだ。 </p>

<p>
  "x" コマンドは、メインメモリに格納されているデータを表示するコマンドで、"x アドレス" というようにして実行する。 
  "x" のあとに"/" と文字を書くと、表示方法を指定できる。/g だと、メモリに格納されたデータを、64bit 値として16進数で表示する。
  上の例では、"x"コマンドを使って、0x800000 のアドレスに格納されているデータを表示している。(completed.6735 ってなんだ！？これはデバッガかリンカの説明ところで掘り下げよう。今は無視してもらって構わない)
</p>

<p>
  &percnt;rax に、0x99 を格納した状態で、&percnt;rax の値を 0x800000にストアしたあとに、"x /g 0x800000" コマンドを実行すると、メモリに0x99 が格納されていること、
  その次にアドレス 0x800000 から &percnt;r8 に0x800000からデータをロードすると、&percnt;r8 の値が0x99 になっていることを確認してほしい。
</p>

<p> あ、アクセスサイズの説明をしていなかった。(TODO:あとで構成を考える) </p>

<p> 
  上の例では、メモリアクセス命令のオペランドとして、rax と r8 を使っていたので、
  メモリアクセスのサイズは64bit(8byteだった)
</p>

<p>
  メインメモリのアクセス単位は1byteだが、このメインメモリに対して、
  8byteのロードをすると、指定したアドレスから、連続する8個分のデータをロードしてくる。
  同様に、8byteのストアをすると、8byteの連続した領域に、8個分のデータをストアする。
</p>

<p>
  この、2byte以上のデータをロード、ストアする方式には、流派がふたつある。リトルエンディアンと、ビッグエンディアンだ。
</p>

<p>
  x86_64 は、リトルエンディアンを採用している。
  リトルエンディアン環境でメモリアクセスを行う環境では、8byte のストアを行うと、順に
</p>

<ol>
  <li> アドレス+0 の位置に、レジスタの0bit目から7bit目までの8bitを格納 </li>
  <li> アドレス+1 の位置に、レジスタの8bit目から15bit目までの8bitを格納 </li>
  <li> アドレス+2 の位置に、レジスタの16bit目から23bit目までの8bitを格納 </li>
  <li> アドレス+3 の位置に、レジスタの24bit目から31bit目までの8bitを格納 </li>
  <li> アドレス+4 の位置に、レジスタの32bit目から39bit目までの8bitを格納 </li>
  <li> アドレス+5 の位置に、レジスタの40bit目から47bit目までの8bitを格納 </li>
  <li> アドレス+6 の位置に、レジスタの48bit目から55bit目までの8bitを格納 </li>
  <li> アドレス+7 の位置に、レジスタの56bit目から63bit目までの8bitを格納 </li>
</ol>

<p> と、なる。ロードは逆に、アドレス+0番の位置にあるデータを、レジスタの0bit目から7bit目まで…というようになる。 </p>

<p> これは、値を表示したとき、人間が見る表示と、メモリに格納されているデータが逆になることを覚えておこう。 </p>

<p> 例えば、64bitの 0x0000000011223344 という値をメモリに格納すると、 </p>

<table>
  <tr> 
    <td> 0byte目 </td>
    <td> 1byte目 </td>
    <td> 2byte目 </td>
    <td> 3byte目 </td>
    <td> 4byte目 </td>
    <td> 5byte目 </td>
    <td> 6byte目 </td>
    <td> 7byte目 </td>
  </tr>

  <tr> 
    <td> 0x44 </td>
    <td> 0x33 </td>
    <td> 0x22 </td>
    <td> 0x11 </td>
    <td> 0x00 </td>
    <td> 0x00 </td>
    <td> 0x00 </td>
    <td> 0x00 </td>
  </tr>
</table>

<p> こうなる </p>

<p> さきほどの例でも、"x" コマンドで 64bit 値 0x99 を格納したあとに、格納されたデータをバイト単位で8byte表示すると(フォーマット指定は8bxだ)、64bit 値が逆順に表示される。</p>

<pre>
(gdb) x/8bx 0x800000
0x800000 &lt;completed.6735&gt;:	0x99	0x00	0x00	0x00	0x00	0x00	0x00	0x00
</pre>

<p>
  一般的なCPUは、レジスタ幅でロードストアする以外に、8bit、16bit、32bit 単位でのロードストアができるようになっている。
  もちろん、x86_64 もそれが可能だ。それぞれ、命令は以下のようになる。
</p>

<table>
  <tr>
    <td> bit幅 </td>
    <td> 符号拡張ロード </td>
    <td> ゼロ拡張ロード </td>
    <td> ストア</td>
  </tr>

  <tr> 
    <td> 32bit </td>
    <td> movsl アドレス,64bit_register </td>
    <td> mov アドレス,32bit_register </td>
    <td> mov 32bit_register, アドレス </td>
  </tr>

  <tr> 
    <td> 16bit </td>
    <td> movsw アドレス,64bit register </td>
    <td> movzw アドレス,64bit register </td>
    <td> mov 16bit_register, アドレス </td>
  </tr>

  <tr> 
    <td> 8bit </td>
    <td> movsb アドレス,64bit register </td>
    <td> movzb アドレス,64bit register </td>
    <td> mov 8bit_register, アドレス </td>
  </tr>
</table>

<p> この表を読むには 2点追加で説明が必要だ。符号拡張と、レジスタ幅だ。</p>

<p> まず符号拡張。コンピュータで扱う整数には、符号付き整数と、符号無し整数がある。C 言語でいうと、signed と unsigned の違いだ。</p>

<p> 
  符号付き整数の場合、ある整数ビット列をより大きなビットを持つ整数ビット列に変換するとき、
  値の整合性を維持する場合、大きくした部分に、変換前の符号ビットをコピーして入れなければならない。
</p>

<p>例えば、符号付き整数-128 は、</p>

<ul>
  <li> 8bit だと二進数で 1000_0000  </li>
  <li> 16bit だと二進数で、1111_1111_1000_0000 </li>
</ul>

<p> となる。また、符号付き整数 +127 は、 </p>

<ul>
  <li> 8bit だと二進数で 0111_1111 </p>
  <li> 16bit だと二進数で、0000_0000_0111_1111 </p>
</ul>

<p> となる。これを見れば拡張されたビット部分に、拡張前の値の符号が入っていることが確認できるはずだ。 </p>

<p>
  ロード命令では、このビット幅の拡張が発生するので、符号拡張ロード命令(signed用)と、ゼロ拡張ロード命令(unsigned用)が用意されている。
</p>

<p>
  ストア命令は、ビット幅が小さくなるほうに変換するので、この問題は発生しない。そのため、符号拡張ストアは存在しない。
</p>

<p> この符号拡張ロードの挙動はどのPUでも大体同じである。次に、レジスタ幅だ。 </p>

<p>
  x86系列のCPUでは、レジスタの下位ビットに名前が付いており、
  このレジスタの下位ビットを示す名前を使うことで、64bitレジスタから、32bit、16bit、8bit値を取り出すことができるようになっている。
</p>

<p> x86_64 では、次のようになる </p>

<table>
  <tr> <td> 64bit レジスタ </td> <td> 32bit レジスタ </td> <td> 16bit レジスタ </td> <td> 8bit レジスタ </td> </tr>
  <tr> <td> rax </td> <td> eax </td> <td> ax </td> <td> al </td> </tr>
  <tr> <td> rbx </td> <td> ebx </td> <td> bx </td> <td> bl </td> </tr>
  <tr> <td> rcx </td> <td> ecx </td> <td> cx </td> <td> cl </td> </tr>
  <tr> <td> rdx </td> <td> edx </td> <td> dx </td> <td> dl </td> </tr>

  <tr> <td> rsi </td> <td> esi </td> <td> si </td> <td> sil </td> </tr>
  <tr> <td> rdi </td> <td> edi </td> <td> di </td> <td> dil </td> </tr>
  <tr> <td> rbp </td> <td> ebp </td> <td> bp </td> <td> bpl </td> </tr>
  <tr> <td> rsp </td> <td> esp </td> <td> sp </td> <td> spl </td> </tr>

  <tr> <td> r8 </td> <td> r8d </td> <td> r8w </td> <td> r8b </td> </tr>
  <tr> <td> r9 </td> <td> r9d </td> <td> r9w </td> <td> r9b </td> </tr>
  <tr> <td> rX </td> <td> rXd(r8-r15はdが付く) </td> <td> rXw(r8-r15はwが付く) </td> <td> rXb(r8-r15はbが付く) </td> </tr>
  <tr> <td> r15 </td> <td> r15d </td> <td> r15w </td> <td> r15b </td> </tr>
</table>

<p> 命名規則がグダグダなのは、x86_64 が 16bit だった時代の名残を背負ってしまっているからだ。このへんの名残は本当にひどくて、さきほどの表 </p>

<table>
  <tr>
    <td> bit幅 </td>
    <td> 符号拡張ロード </td>
    <td> ゼロ拡張ロード </td>
    <td> ストア</td>
  </tr>

  <tr> 
    <td> 32bit </td>
    <td> movsx アドレス,64bit_register </td>
    <td> mov アドレス,32bit_register </td>
    <td> mov 32bit_register, アドレス </td>
  </tr>

  <tr> 
    <td> 16bit </td>
    <td> movsx アドレス,64bit register </td>
    <td> movzx アドレス,64bit register </td>
    <td> mov 16bit_register, アドレス </td>
  </tr>

  <tr> 
    <td> 8bit </td>
    <td> movsx アドレス,64bit register </td>
    <td> movzx アドレス,64bit register </td>
    <td> mov 8bit_register, アドレス </td>
  </tr>
</table>

<p> を見ても、何かルールがありそうな、なさそうな形をしているし、あと、add などの算術演算は、レジスタの下位16bit や 下位32bit だけで演算できて、add のオペランドに、alレジスタなどを入れると8bit加算ができたりするのだけど、8bit、16bit算術演算は性能上の理由で使用が推奨されていない、が、64bit環境でも、32bit 算術演算が使える場合は使ったほうが性能上わずかに有利とか、そういう初見殺しルールがあったりする。(この話は<a href="http://d.hatena.ne.jp/w_o/20140828#1409230235"> nopの話 </a> とあわせて結構好きなネタなので、気が向いたら書く) </p>

<p> その話はともかく、現代のx86_64では、名前のルールにひどい仕様が残っているものの、正しい命令を使えば実行時の悪影響はゼロにすることができて、コンパイラは効率良いコードを出すので安心してほしい。 基本的には、上の表に書いた命令を使っていればよい。 </p>

<p> 符号拡張の挙動を見ておこう </p>

<p> <a href="small-load-store.s"> small-load-store.s </a> </p>

<pre>
	# gcc -static -no-pie -Tbss=0x800000 small-load-store.s でビルドすること

	.globl main
main:
	mov	$0xff, %rax
	mov	%al, 0x800000 	# 1byte の 0xff を 0x800000 にストア
	movsxb	0x800000, %r8

	ret
</pre>

<pre>
(gdb) display /4i $pc
1: x/4i $pc
&lt;error: No registers.&gt;
(gdb) start
Temporary breakpoint 1 at 0x401106
Starting program: /home/w0/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x0000000000401106 in main ()
1: x/4i $pc
=&gt; 0x401106 &lt;main&gt;:	mov    $0xff,%rax
   0x40110d &lt;main+7&gt;:	mov    %al,0x800000
   0x401114 &lt;main+14&gt;:	movsbq 0x800000,%r8
   0x40111d &lt;main+23&gt;:	retq   
(gdb) stepi
0x000000000040110d in main ()
1: x/4i $pc
=&gt; 0x40110d &lt;main+7&gt;:	mov    %al,0x800000
   0x401114 &lt;main+14&gt;:	movsbq 0x800000,%r8
   0x40111d &lt;main+23&gt;:	retq   
   0x40111e &lt;main+24&gt;:	xchg   %ax,%ax
(gdb) stepi
0x0000000000401114 in main ()
1: x/4i $pc
=&gt; 0x401114 &lt;main+14&gt;:	movsbq 0x800000,%r8
   0x40111d &lt;main+23&gt;:	retq   
   0x40111e &lt;main+24&gt;:	xchg   %ax,%ax
   0x401120 &lt;__libc_csu_init&gt;:	endbr64 
(gdb) x/8bx 0x800000
0x800000 &lt;completed.7286&gt;:	0xff	0x00	0x00	0x00	0x00	0x00	0x00	0x00
(gdb) stepi
0x000000000040111d in main ()
1: x/4i $pc
=&gt; 0x40111d &lt;main+23&gt;:	retq   
   0x40111e &lt;main+24&gt;:	xchg   %ax,%ax
   0x401120 &lt;__libc_csu_init&gt;:	endbr64 
   0x401124 &lt;__libc_csu_init+4&gt;:	push   %r15
(gdb) p $r8
$1 = -1
(gdb) p /x $r8
$2 = 0xffffffffffffffff
</pre>

<p> 
  一個便利な gdb コマンドを説明しておこう。"display" だ。 "display" は、"x"や"print" とほぼ同じコマンドだが、
  一度 "display" コマンドを実行すると、以降は、gdbのコマンドを実行するごとに、毎回式やメモリのダンプ結果を表示してくれる。
  "display /4i $pc" は、"プログラムカウンタが指す位置にあるメモリの中身を命令として4個分表示しろ"と指示するコマンドだ。
  一旦これを書いておけば、以降はgdbのコマンドを実行するごとにプログラムカウンタ周辺の命令をダンプしてくれるようになる。
</p>

<p> rax レジスタに、1byteの-1 (0xff) を格納後、その下位8bit をストア、それを符号拡張してロードし、r8レジスタに入れると、r8 レジスタの値が64bit値の-1 (0xffff_ffff_ffff_ffff) になっていることを確認しよう。 </p>


<p> そしてまたもう一個必要な説明が抜けていた。メモリオペランドのサイズだ。 </p>

<p> movsx は、単なる mov と違い、ニーモニックとオペランドのペアから実行する機械語が一意に定まらない。 </p>

<pre>
     movsx $0x800000, %rax  # 8bit 符号拡張ロード (?)
     movsx $0x800000, %rax  # 16bit 符号拡張ロード (?)
     movsx $0x800000, %rax  # 32bit 符号拡張ロード (?)
</pre>

<p>
  何かしらの方法で、ロードするデータのサイズを明示的に指示する必要がある。
  これもまた初心者殺しで、AT&amp;T記法と、Intel記法で指示する方法が違う。
</p>

<p> AT&amp;T 記法では、命令のニーモニックに、ロードするサイズを指示する接尾辞を付ける。
  8bit なら "b"、16bit なら "w"、32bit なら "l" だ。
</p>

<pre>
     movsxb $0x800000, %rax  # 8bit 符号拡張ロード
     movsxw $0x800000, %rax  # 16bit 符号拡張ロード
     movsxl $0x800000, %rax  # 32bit 符号拡張ロード
</pre>

<p> Intel 記法では、メモリオペランドのほうに、ロードするデータのサイズを書く。 
  (Intel記法にもさらに流派があって、nasm では PTR を書かないようだ。
  筆者はもうよくわからないので詳細は近くの詳しい人に聞いてほしい)
</p>

<pre>
     movsx rax, BYTE PTR [0x800000] ; 8bit 符号拡張ロード
     movsx rax, WORD PTR [0x800000] ; 8bit 符号拡張ロード
     movsx rax, DWORD PTR [0x800000] ; 8bit 符号拡張ロード
</pre>


<p> 
  さて、これで必要なことはひととおり説明したはずなので、ロードストア命令について掘り下げていこう。
</p>


<p> メインメモリのメモリアドレスは、整数値だと書いた。この整数値は、レジスタに入っていても構わない。 </p>

<p> 
  レジスタに含まれる整数値を使って、メインメモリを参照することを、<em>レジスタ間接参照 (register indirect addresssing) </em> と呼ぶ。</p>

<p>
  x86_64 の AT&amp;T 記法では、レジスタ名を丸括弧'()'で囲むと、そのレジスタを使ったレジスタ間接参照になる。
</p>

<p> <a href="1/register-indirect.s"> 1/register-indirect.s </a> </p>

<pre>
	# gcc -static -no-pie -Tbss=0x800000 load-v2.s のようにビルドすれば、0x800000 のアドレスに
	# メインメモリがOSから割り当てられた状態でプログラムが起動する実行ファイルを作ることができる

	.globl	main
main:
	mov $0x99, %rax
	mov %rax, 0x800000      # 0x800000 に 0x99 をストア

	mov $0x800000, %rdx 	# RDX に整数値0x800000 を入れる
	mov (%rdx), %r8         # RDXの値(0x800000)をアドレスとして、メインメモリからロード
	
	ret
</pre>

<p> これを実行してみよう </p>

<pre>
(gdb) display /4i $pc
1: x/4i $pc
&lt;error: No registers.&gt;
(gdb) start
Temporary breakpoint 1 at 0x401106
Starting program: /home/w0/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x0000000000401106 in main ()
1: x/4i $pc
=&gt; 0x401106 &lt;main&gt;:	mov    $0x99,%rax
   0x40110d &lt;main+7&gt;:	mov    %rax,0x800000
   0x401115 &lt;main+15&gt;:	mov    $0x800000,%rdx
   0x40111c &lt;main+22&gt;:	mov    (%rdx),%r8
(gdb) stepi
0x000000000040110d in main ()
1: x/4i $pc
=&gt; 0x40110d &lt;main+7&gt;:	mov    %rax,0x800000
   0x401115 &lt;main+15&gt;:	mov    $0x800000,%rdx
   0x40111c &lt;main+22&gt;:	mov    (%rdx),%r8
   0x40111f &lt;main+25&gt;:	retq   
(gdb) 
0x0000000000401115 in main ()
1: x/4i $pc
=&gt; 0x401115 &lt;main+15&gt;:	mov    $0x800000,%rdx
   0x40111c &lt;main+22&gt;:	mov    (%rdx),%r8
   0x40111f &lt;main+25&gt;:	retq   
   0x401120 &lt;__libc_csu_init&gt;:	endbr64 
(gdb) 
0x000000000040111c in main ()
1: x/4i $pc
=&gt; 0x40111c &lt;main+22&gt;:	mov    (%rdx),%r8
   0x40111f &lt;main+25&gt;:	retq   
   0x401120 &lt;__libc_csu_init&gt;:	endbr64 
   0x401124 &lt;__libc_csu_init+4&gt;:	push   %r15
(gdb) 
0x000000000040111f in main ()
1: x/4i $pc
=&gt; 0x40111f &lt;main+25&gt;:	retq   
   0x401120 &lt;__libc_csu_init&gt;:	endbr64 
   0x401124 &lt;__libc_csu_init+4&gt;:	push   %r15
   0x401126 &lt;__libc_csu_init+6&gt;:	mov    %rdx,%r15
(gdb) p /x $rdx
$1 = 0x800000
(gdb) p /x $r8
$2 = 0x99
</pre>

<p>
  ここで重要なことは、アドレスは整数値で、その整数値がレジスタに入っているということだ。
  レジスタに入っている整数値は、add 命令などを使って算術演算を行うことができた。
  つまり、<em>アドレスは算術演算することが可能</em>だ。
</p>

<p> (TODO:"算術演算"の説明を書いてない) </p>

<p> <a href="1/address-arith.s"> 1/address-arith.s </a> </p>

<pre>
	# gcc -static -no-pie -Tbss=0x800000 address-arith.s のようにビルドする

	.globl	main
main:
	movb $0x0, 0x800000 # 0x800000 から順番に 8個データを保存
	movb $0x1, 0x800001
	movb $0x2, 0x800002
	movb $0x3, 0x800003

	mov $0x800000, %rax # %rax に整数値0x800000を格納
	mov $0, %r8         # %r8 ゼロ初期化

	movsxb (%rax), %r9
	add %r9, %r8
	add $1, %rax

	movsxb (%rax), %r9
	add %r9, %r8
	add $1, %rax

	movsxb (%rax), %r9
	add %r9, %r8
	add $1, %rax
	
	ret
</pre>

<pre>
(gdb) start
Temporary breakpoint 1 at 0x401106
Starting program: /home/w0/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x0000000000401106 in main ()
(gdb) display /4xb 0x800000
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x00	0x00	0x00
(gdb) display /x $rax
2: /x $rax = 0x401106
(gdb) display $r8
3: $r8 = 140737353694176
(gdb) display $r9
4: $r9 = 140737353694176
(gdb) display /4i $pc
5: x/4i $pc
=&gt; 0x401106 &lt;main&gt;:	mov    $0x0,%r8
   0x40110d &lt;main+7&gt;:	mov    $0x0,%r9
   0x401114 &lt;main+14&gt;:	movb   $0x0,0x800000
   0x40111c &lt;main+22&gt;:	movb   $0x1,0x800001
(gdb) stepi
0x000000000040110d in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x00	0x00	0x00
2: /x $rax = 0x401106
3: $r8 = 0
4: $r9 = 140737353694176
5: x/4i $pc
=&gt; 0x40110d &lt;main+7&gt;:	mov    $0x0,%r9
   0x401114 &lt;main+14&gt;:	movb   $0x0,0x800000
   0x40111c &lt;main+22&gt;:	movb   $0x1,0x800001
   0x401124 &lt;main+30&gt;:	movb   $0x2,0x800002
(gdb) stepi
0x0000000000401114 in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x00	0x00	0x00
2: /x $rax = 0x401106
3: $r8 = 0
4: $r9 = 0
5: x/4i $pc
=&gt; 0x401114 &lt;main+14&gt;:	movb   $0x0,0x800000
   0x40111c &lt;main+22&gt;:	movb   $0x1,0x800001
   0x401124 &lt;main+30&gt;:	movb   $0x2,0x800002
   0x40112c &lt;main+38&gt;:	movb   $0x3,0x800003
(gdb) 
0x000000000040111c in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x00	0x00	0x00
2: /x $rax = 0x401106
3: $r8 = 0
4: $r9 = 0
5: x/4i $pc
=&gt; 0x40111c &lt;main+22&gt;:	movb   $0x1,0x800001
   0x401124 &lt;main+30&gt;:	movb   $0x2,0x800002
   0x40112c &lt;main+38&gt;:	movb   $0x3,0x800003
   0x401134 &lt;main+46&gt;:	mov    $0x800000,%rax
(gdb) 
0x0000000000401124 in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x00	0x00
2: /x $rax = 0x401106
3: $r8 = 0
4: $r9 = 0
5: x/4i $pc
=&gt; 0x401124 &lt;main+30&gt;:	movb   $0x2,0x800002
   0x40112c &lt;main+38&gt;:	movb   $0x3,0x800003
   0x401134 &lt;main+46&gt;:	mov    $0x800000,%rax
   0x40113b &lt;main+53&gt;:	movsbq (%rax),%r9
(gdb) 
0x000000000040112c in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x00
2: /x $rax = 0x401106
3: $r8 = 0
4: $r9 = 0
5: x/4i $pc
=&gt; 0x40112c &lt;main+38&gt;:	movb   $0x3,0x800003
   0x401134 &lt;main+46&gt;:	mov    $0x800000,%rax
   0x40113b &lt;main+53&gt;:	movsbq (%rax),%r9
   0x40113f &lt;main+57&gt;:	add    %r9,%r8
(gdb) 
0x0000000000401134 in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x03
2: /x $rax = 0x401106
3: $r8 = 0
4: $r9 = 0
5: x/4i $pc
=&gt; 0x401134 &lt;main+46&gt;:	mov    $0x800000,%rax
   0x40113b &lt;main+53&gt;:	movsbq (%rax),%r9
   0x40113f &lt;main+57&gt;:	add    %r9,%r8
   0x401142 &lt;main+60&gt;:	add    $0x1,%rax
(gdb) 
0x000000000040113b in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x03
2: /x $rax = 0x800000
3: $r8 = 0
4: $r9 = 0
5: x/4i $pc
=&gt; 0x40113b &lt;main+53&gt;:	movsbq (%rax),%r9
   0x40113f &lt;main+57&gt;:	add    %r9,%r8
   0x401142 &lt;main+60&gt;:	add    $0x1,%rax
   0x401146 &lt;main+64&gt;:	movsbq (%rax),%r9
(gdb) 
0x000000000040113f in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x03
2: /x $rax = 0x800000
3: $r8 = 0
4: $r9 = 0
5: x/4i $pc
=&gt; 0x40113f &lt;main+57&gt;:	add    %r9,%r8
   0x401142 &lt;main+60&gt;:	add    $0x1,%rax
   0x401146 &lt;main+64&gt;:	movsbq (%rax),%r9
   0x40114a &lt;main+68&gt;:	add    %r9,%r8
(gdb) 
0x0000000000401142 in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x03
2: /x $rax = 0x800000
3: $r8 = 0
4: $r9 = 0
5: x/4i $pc
=&gt; 0x401142 &lt;main+60&gt;:	add    $0x1,%rax
   0x401146 &lt;main+64&gt;:	movsbq (%rax),%r9
   0x40114a &lt;main+68&gt;:	add    %r9,%r8
   0x40114d &lt;main+71&gt;:	add    $0x1,%rax
(gdb) 
0x0000000000401146 in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x03
2: /x $rax = 0x800001
3: $r8 = 0
4: $r9 = 0
5: x/4i $pc
=&gt; 0x401146 &lt;main+64&gt;:	movsbq (%rax),%r9
   0x40114a &lt;main+68&gt;:	add    %r9,%r8
   0x40114d &lt;main+71&gt;:	add    $0x1,%rax
   0x401151 &lt;main+75&gt;:	movsbq (%rax),%r9
(gdb) 
0x000000000040114a in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x03
2: /x $rax = 0x800001
3: $r8 = 0
4: $r9 = 1
5: x/4i $pc
=&gt; 0x40114a &lt;main+68&gt;:	add    %r9,%r8
   0x40114d &lt;main+71&gt;:	add    $0x1,%rax
   0x401151 &lt;main+75&gt;:	movsbq (%rax),%r9
   0x401155 &lt;main+79&gt;:	add    %r9,%r8
(gdb) 
0x000000000040114d in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x03
2: /x $rax = 0x800001
3: $r8 = 1
4: $r9 = 1
5: x/4i $pc
=&gt; 0x40114d &lt;main+71&gt;:	add    $0x1,%rax
   0x401151 &lt;main+75&gt;:	movsbq (%rax),%r9
   0x401155 &lt;main+79&gt;:	add    %r9,%r8
   0x401158 &lt;main+82&gt;:	add    $0x1,%rax
(gdb) 
0x0000000000401151 in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x03
2: /x $rax = 0x800002
3: $r8 = 1
4: $r9 = 1
5: x/4i $pc
=&gt; 0x401151 &lt;main+75&gt;:	movsbq (%rax),%r9
   0x401155 &lt;main+79&gt;:	add    %r9,%r8
   0x401158 &lt;main+82&gt;:	add    $0x1,%rax
   0x40115c &lt;main+86&gt;:	movsbq (%rax),%r9
(gdb) 
0x0000000000401155 in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x03
2: /x $rax = 0x800002
3: $r8 = 1
4: $r9 = 2
5: x/4i $pc
=&gt; 0x401155 &lt;main+79&gt;:	add    %r9,%r8
   0x401158 &lt;main+82&gt;:	add    $0x1,%rax
   0x40115c &lt;main+86&gt;:	movsbq (%rax),%r9
   0x401160 &lt;main+90&gt;:	add    %r9,%r8
(gdb) 
0x0000000000401158 in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x03
2: /x $rax = 0x800002
3: $r8 = 3
4: $r9 = 2
5: x/4i $pc
=&gt; 0x401158 &lt;main+82&gt;:	add    $0x1,%rax
   0x40115c &lt;main+86&gt;:	movsbq (%rax),%r9
   0x401160 &lt;main+90&gt;:	add    %r9,%r8
   0x401163 &lt;main+93&gt;:	retq   
(gdb) 
0x000000000040115c in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x03
2: /x $rax = 0x800003
3: $r8 = 3
4: $r9 = 2
5: x/4i $pc
=&gt; 0x40115c &lt;main+86&gt;:	movsbq (%rax),%r9
   0x401160 &lt;main+90&gt;:	add    %r9,%r8
   0x401163 &lt;main+93&gt;:	retq   
   0x401164 &lt;main+94&gt;:	nopw   %cs:0x0(%rax,%rax,1)
(gdb) 
0x0000000000401160 in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x03
2: /x $rax = 0x800003
3: $r8 = 3
4: $r9 = 3
5: x/4i $pc
=&gt; 0x401160 &lt;main+90&gt;:	add    %r9,%r8
   0x401163 &lt;main+93&gt;:	retq   
   0x401164 &lt;main+94&gt;:	nopw   %cs:0x0(%rax,%rax,1)
   0x40116e &lt;main+104&gt;:	xchg   %ax,%ax
(gdb) 
0x0000000000401163 in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x01	0x02	0x03
2: /x $rax = 0x800003
3: $r8 = 6
4: $r9 = 3
5: x/4i $pc
=&gt; 0x401163 &lt;main+93&gt;:	retq   
   0x401164 &lt;main+94&gt;:	nopw   %cs:0x0(%rax,%rax,1)
   0x40116e &lt;main+104&gt;:	xchg   %ax,%ax
   0x401170 &lt;__libc_csu_init&gt;:	endbr64 
(gdb) 
</pre>

<p> 
  rax レジスタに入れた値を +1 していくと、メインメモリの連続した領域に格納した値を順番に読んでいけることを確認してほしい。
  (重要な部分なので、できればちゃんと理解できるまで手元で実行して確認することをおすすめする。また、余裕があれば、プログラムを改変して、動きがどう変わるかなども確認してほしい)
</p>

<p>
  またいくつか説明していないことが出てきたので説明しておこう。
</p>

<pre>
	movb $0x0, 0x800000 # 0x800000 から順番に 8個データを保存
	movb $0x1, 0x800001
	movb $0x2, 0x800002
	movb $0x3, 0x800003
</pre>

<p> 
  x86_64 では、即値を直接メインメモリにストアすることができる。
  (これができるCPUは現代ではx86系のCPUぐらいで、ARMやPowerPC、MIPSはできない)
  operand0 にメモリアドレス、operand1 に即値を書く。
  詳しくは、またあとのx86_64機械語の説明のところで説明しよう。
</p>

<p>
  この場合は、mov ではなく、mov"b" 命令を使っている点に注意してほしい。
  この "b" は、movsx のところで書いたサイズを指定する接尾辞と同じもので、
  この mov 命令が1byteの値をmovするように指定している。
</p>

<p> ここで、単に "mov" 命令を使ってしまうと、 </p>

<pre>
	mov $0x0, 0x800000 # 0x800000 から順番に 8個データを保存
	mov $0x1, 0x800001
	mov $0x2, 0x800002
	mov $0x3, 0x800003
</pre>

<p> ストアするバイト数が一意に定まらない。このような場合には、明示的に "b" を付ける。 </p>

<p>
  この接尾辞は、命令がオペランドサイズから一意に定まる場合にも付けてよくて、
  例えばレジスタ間転送する場合は、レジスタ名から転送サイズが一意に定まるが、その場合にも接尾辞を付けてよい
</p>

<pre>
  mov %rax, %rcx    # 8 byte 転送
  movq %rax, %rcx   # 8 byte 転送 (q は 8byte の意味)
</pre>

<p> 次に、gdb のコマンドを見てほしいが、 </p>

<pre>
(gdb) stepi
0x0000000000401114 in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x00	0x00	0x00
2: /x $rax = 0x401106
3: $r8 = 0
4: $r9 = 0
5: x/4i $pc
=&gt; 0x401114 &lt;main+14&gt;:	movb   $0x0,0x800000
   0x40111c &lt;main+22&gt;:	movb   $0x1,0x800001
   0x401124 &lt;main+30&gt;:	movb   $0x2,0x800002
   0x40112c &lt;main+38&gt;:	movb   $0x3,0x800003
(gdb) 
0x000000000040111c in main ()
1: x/4xb 0x800000
0x800000 &lt;completed.7286&gt;:	0x00	0x00	0x00	0x00
2: /x $rax = 0x401106
3: $r8 = 0
4: $r9 = 0
5: x/4i $pc
=&gt; 0x40111c &lt;main+22&gt;:	movb   $0x1,0x800001
   0x401124 &lt;main+30&gt;:	movb   $0x2,0x800002
   0x40112c &lt;main+38&gt;:	movb   $0x3,0x800003
   0x401134 &lt;main+46&gt;:	mov    $0x800000,%rax
</pre>

<p> ここで、二回目は、"stepi" コマンドを入力していない点が気になる人もいるかもしれない。 </p>

<p> 
  gdb のプロンプトでは、単にエンターキーを押すと、最後に入力したコマンドがもう一度実行される。
  ここでは、直前のコマンドは"stepi"なので、この何もコマンドを入れていない行は、
  "stepi"をコマンドを入力したことになっている。
</p>


<p>
  ロードストアの説明はこのあたりにしておこう。
</p>

<p>
  低レベルプログラミングをする場合、ロードストア命令についての正しい理解が求められる場面がかなり多い。
  きちんと正しい理解が得られるまで、ゆっくり色々試行錯誤してみるのがよいと思う。
</p>



<h3> プログラムカウンタと分岐 </h3>

<p>
  レジスタについて解説したところで、
</p>

<ul>
  <li> プログラムカウンタ : 現在実行している命令のアドレスを保持する。これもx86_64では64bit。値を操作するのに特殊な命令が必要 </li>
</ul>

<p> と、いうのを書いていた。</p>

<p>
  現代の一般的なCPUでは、プログラムは、データと本質的な違いはなく、
  メモリ上に配置されたデータと同じように、メインメモリ上の"どこか"に配置されたバイト列である。
  CPU は命令を実行するとき、このメインメモリ上に配置された命令バイト列を、メインメモリからロードしてくる(このロードは<em>フェッチ(fetch)</em>と呼ばれる)。
</p>
  

<p>
  ロードストア命令のところで、
</p>

<pre>
  mov (%rax), %rdx
</pre>

<p> のように書くと、レジスタに含まれる整数値をアドレスとして使ってメインメモリを参照する、「レジスタ間接参照」ができると説明した。 </p>

<p> <em>フェッチ</em>は、プログラムカウンタを使ってレジスタ間接参照して、命令バイト列をロードしてくる動作だとも言える。 </p>

<p> まずは、CPUの命令は単なるバイト列でしかないことを確認しておこう </p>

<p> <a href="1/self-modified.s"> 1/self-modified.s </a> </p>

<pre>
	.section "axw", "axw"
	.globl main

main:
	movl	$0x11223344, mov_inst+3

	jmp	1f              # プログラムを書きかえたあとに必要
1:	nop                     # プログラムを書きかえたあとに必要

mov_inst:
	mov	$0x1, %rax 	# 0x48 0xc7 0xc0 0x01 0x00 0x00 0x00
	ret
</pre>

<p> いくつか説明していないことが含まれているが、とりあえず実行してみる。 </p>

<pre>
(gdb) start
Temporary breakpoint 1 at 0x404028
Starting program: /home/w0/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x0000000000404028 in main ()
(gdb) display /x5i $pc
Invalid number "5i".
(gdb) display /5i $pc
1: x/5i $pc
=&gt; 0x404028 &lt;main&gt;:	movl   $0x11223344,0x404039
   0x404033 &lt;main+11&gt;:	jmp    0x404035 &lt;main+13&gt;
   0x404035 &lt;main+13&gt;:	nop
   0x404036 &lt;mov_inst&gt;:	mov    $0x1,%rax
   0x40403d &lt;mov_inst+7&gt;:	retq   
(gdb) display /8xb mov_inst
2: x/8xb mov_inst
0x404036 &lt;mov_inst&gt;:	0x48	0xc7	0xc0	0x01	0x00	0x00	0x00	0xc3
(gdb) stepi
0x0000000000404033 in main ()
1: x/5i $pc
=&gt; 0x404033 &lt;main+11&gt;:	jmp    0x404035 &lt;main+13&gt;
   0x404035 &lt;main+13&gt;:	nop
   0x404036 &lt;mov_inst&gt;:	mov    $0x11223344,%rax
   0x40403d &lt;mov_inst+7&gt;:	retq   
   0x40403e:	rex.RXB
2: x/8xb mov_inst
0x404036 &lt;mov_inst&gt;:	0x48	0xc7	0xc0	0x44	0x33	0x22	0x11	0xc3
(gdb) stepi
0x0000000000404035 in main ()
1: x/5i $pc
=&gt; 0x404035 &lt;main+13&gt;:	nop
   0x404036 &lt;mov_inst&gt;:	mov    $0x11223344,%rax
   0x40403d &lt;mov_inst+7&gt;:	retq   
   0x40403e:	rex.RXB
   0x40403f:	rex.XB
2: x/8xb mov_inst
0x404036 &lt;mov_inst&gt;:	0x48	0xc7	0xc0	0x44	0x33	0x22	0x11	0xc3
(gdb) stepi
0x0000000000404036 in mov_inst ()
1: x/5i $pc
=&gt; 0x404036 &lt;mov_inst&gt;:	mov    $0x11223344,%rax
   0x40403d &lt;mov_inst+7&gt;:	retq   
   0x40403e:	rex.RXB
   0x40403f:	rex.XB
   0x404040:	rex.XB cmp (%r8),%spl
2: x/8xb mov_inst
0x404036 &lt;mov_inst&gt;:	0x48	0xc7	0xc0	0x44	0x33	0x22	0x11	0xc3
(gdb) stepi
0x000000000040403d in mov_inst ()
1: x/5i $pc
=&gt; 0x40403d &lt;mov_inst+7&gt;:	retq   
   0x40403e:	rex.RXB
   0x40403f:	rex.XB
   0x404040:	rex.XB cmp (%r8),%spl
   0x404043:	sub    %al,0x4e(%rdi)
2: x/8xb mov_inst
0x404036 &lt;mov_inst&gt;:	0x48	0xc7	0xc0	0x44	0x33	0x22	0x11	0xc3
(gdb) p /x $rax
$1 = 0x11223344
(gdb) 
</pre>

<p>
  以下の部分で、main の先頭にある mov 命令によるストアの実行後、mov $1, &percnt;rax の命令が書きかわっていることを確認しよう。
</p>

<pre>
(gdb) display /5i $pc
1: x/5i $pc
=&gt; 0x404028 &lt;main&gt;:	movl   $0x11223344,0x404039 <font color="red">&lt;= このストアの実行後</font>
   0x404033 &lt;main+11&gt;:	jmp    0x404035 &lt;main+13&gt;
   0x404035 &lt;main+13&gt;:	nop
   0x404036 &lt;mov_inst&gt;:	mov    $0x1,%rax            <font color="red">&lt;= mov $0x1, &percnt;rax が</font>
   0x40403d &lt;mov_inst+7&gt;:	retq   
(gdb) display /8xb mov_inst
2: x/8xb mov_inst
0x404036 &lt;mov_inst&gt;:	0x48	0xc7	0xc0	0x01	0x00	0x00	0x00	0xc3
(gdb) stepi
0x0000000000404033 in main ()
1: x/5i $pc
=&gt; 0x404033 &lt;main+11&gt;:	jmp    0x404035 &lt;main+13&gt;
   0x404035 &lt;main+13&gt;:	nop
   0x404036 &lt;mov_inst&gt;:	mov    $0x11223344,%rax     <font color="red">&lt;= mov $0x11223344, %rax に書きかわっている</font>
   0x40403d &lt;mov_inst+7&gt;:	retq   
   0x40403e:	rex.RXB
2: x/8xb mov_inst
0x404036 &lt;mov_inst&gt;:	0x48	0xc7	0xc0	0x44	0x33	0x22	0x11	0xc3
</pre>

<p> また、最後に、rax の値が、0x11223344 になっており、実際に命令が書きかわって効果があらわれていることを確認しよう。 </p>

<pre>
(gdb) p /x $rax
$1 = 0x11223344
</pre>

<p> "mov $0x1, %rax" という文は、メインメモリ上では、0x48 0xc7 0xc0 0x01 0x00 0x00 0x00 というバイト列として表現される。</p>

<p>
  objdump というコマンドに、"-d" と、実行ファイルを渡すと、
  その実行ファイルに含まれる命令一覧と
  その命令のバイト列を知ることができる
</p>


<pre>
$ objdump -d a.out
セクション axw の逆アセンブル:

0000000000404028 &lt;main&gt;:
  404028:       c7 04 25 39 40 40 00    movl   $0x11223344,0x404039
  40402f:       44 33 22 11 
  404033:       eb 00                   jmp    404035 &lt;main+0xd&gt;
  404035:       90                      nop

0000000000404036 &lt;mov_inst&gt;:
  404036:       48 c7 c0 01 00 00 00    mov    $0x1,%rax
  40403d:       c3                      retq   
</pre>

<p> これを見れば、mov $0x1,&percnt;rax が、0x48 0xc7 0xc0 0x01 0x00 0x00 0x00 になることが確認できる。(筆者も別に覚えているわけではなくて、これを見てカンニングしている) </p>


<p> このバイト列の意味は、 </p>


<pre> 
# x86_64 はリトルエンディアンなので、32bit値をバイト毎に表示すると順序が反対に表示されることに注意
48 c7 c0       01 00 00 00    mov    $0x1,%rax
mov imm,rax    imm=0x00000001

</pre>

<p> と、なっていて、最初の3byteで、即値(<font color="red">imm</font>ediate)をraxに転送するmov命令だとあらわしていて、後ろの4byteで、転送するimmの32bit値をあらわしている。 
後ろの4byteはそのまま32bit値なので、これを書きかえれば、命令中の即値が変わる。
</p>

<pre> 
# x86_64 はリトルエンディアンなので、32bit値をバイト毎に表示すると順序が反対に表示されることに注意
48 c7 c0       44 33 22 11    mov    $0x11223344,%rax
mov imm,rax    imm=0x11223344

</pre>


<p>
  このように書きかえているのが、上のプログラムだ。
  このプログラムの挙動を見れば、CPUの命令というのはメインメモリに配置されたバイト列だということがわかるだろう。
  (これも大事なのでわからない人は連絡ください)
</p>



<p> いくつか説明していないことが出てきたのでその点の説明をしておこう。 </p>

<p> まず、</p>

<pre>
	.section "axw", "axw"
</pre>

<p> 
  これは…これはですね…リンカのところで説明します(そればっかやな…)。
</p>

<p>
  簡単に説明すると、OSの上で動くプログラムのアドレスは、「読み取り可能」「書き込み可能」「実行可能」というみっつの属性を持っていて、その属性を指示する文がこの.sectionになる。

</p>

<p>
  OS上のプログラムでは、アドレスに対する操作と、アドレスの属性があっていないと、
  メモリ保護の仕組みが働いて、プログラムが止められてしまう。
  今は、命令バイト列に対する書き込み操作をしたいのだが、一般的なプログラムでは、
  命令バイト列に対して書き込みをすることはまずないので、命令バイト列に対する書き込みは禁止されている。
  つまり、この.section文を書かないでプログラムを実行すると、OSによってプログラムが停止させられてしまう。
  (section文を消して確認してみてほしい)
</p>
  

<p> 次に、 </p>

<pre>
	jmp	1f              # プログラムを書きかえたあとに必要
1:	nop                     # プログラムを書きかえたあとに必要
</pre>

<p>
  この部分は、Intel のマニュアルにこうしろと書いてあるから書いている。
  x86_64 では、命令列を書きかえたあとは、一旦この命令を実行しないといけない。

  これが必要な理由は、CPUハードウェアの実装によるので、正しい説明はできないが、
  簡単に説明しておくと、CPUの命令をバイト列として実行時に書きかえるのは、滅多にやらないことなので、
  CPU内部では、データ用バイト列が流れる道と、命令用のバイト列が流れる道が別々に設計してあることが多い。
  そのふたつの道をちゃんと同期するために、この処理が必要だ。
</p>

<p> それから、 </p>

<pre>
	movl	$0x11223344, mov_inst+3
        ...
mov_inst:
        ...
</pre>

<p> この、mov_inst…これも…詳しくはリンカのところで説明しゅる… </p>

<p>
  一応、簡単に説明しておこう。"main関数" のところで
</p>

<pre>
main:
</pre>

<p> と、書けば、"<em>ラベル</em>というCのmain関数のようなもの"になると説明した。</p>

<p> ここの </p>

<pre>
mov_inst:
</pre>

<p> も、main: と同じくラベルになる。ラベルは、整数値アドレスと同じように、アセンブリ言語内で、アドレスのように扱うことができる。 </p>

<pre>
label:
        mov 0x800000, %rax  # movのようにオペランドにメモリアドレスを取れる命令は、
        mov label, %rax     # 同じようにラベルをオペランドに取ることができる
</pre>

<p>
  リンカは、大量の命令バイト列を一個のファイルにまとめるという処理をし、命令が配置されるアドレスを確定する。
  ということは、つまり、命令が配置されるアドレスは、リンクの処理が終わるまで確定しないということである。
</p>

<pre>
label:
        add $1, %rax        # この add 命令が配置されるアドレスは、リンクが終わるまで確定しない
        mov 0x800000, %rax  #
        mov label, %rax     #
</pre>

<p>
  しかし、データや命令が配置されるアドレスが知りたい場合はよくあるので、これをなんとかしたい。
  そういう時に<em>ラベル</em>が使われる。
</p>

<pre>
        nop
        nop
        nop
label:
        add $1, %rax        #
        mov 0x800000, %rax  #
        mov label, %rax     #
</pre>

<p>
  リンク後、このようにadd命令の上に 3byte 分の命令が追加されたとしよう。
  プログラムがアドレス0番から始まっているとすると、add 命令が配置されるアドレスは、3 byte目だ。
</p>

<p>
  この時、リンカは、ラベルの置かれているアドレスを確定させて、
  整合性が取れるようにそのラベルを参照している命令の一部を書きかえる。
</p>

<pre>
        nop
        nop
        nop
label:  # ← ここは3byte目
        add $1, %rax        #
        mov 0x800000, %rax  #
        mov 0x3, %rax       # ラベル "label" への参照を、確定したlabelのアドレス(0x3) におきかえる。
</pre>


<p> このようになる。 </p>

<p> 上で書いた例をもう一度見てみよう </p>

<pre>
	.section "axw", "axw"
	.globl main

main:
	movl	$0x11223344, mov_inst+3   # ラベルmov_inst から +3 byte した位置を参照

	jmp	1f
1:	nop

mov_inst:                       # 書きかえたい命令の位置にラベルを置く
	mov	$0x1, %rax 	# 0x48 0xc7 0xc0 0x01 0x00 0x00 0x00 のうち、書きかえたいのは命令の中の3byte目から
	ret
</pre>


<p> 
  今やりたいことは、mov 命令の中の32bit値の書きかえだった。
  ところが、リンクが終わるまで、mov 命令のアドレスは確定しない。
  そこで、書きかえたいmov命令にラベルを置いて、リンク後に確定したmov命令の位置を参照できるようにしている。
</p>

<p> gdb が出力した命令のダンプを見てほしい </p>

<pre>
(gdb) display /5i $pc
1: x/5i $pc
=&gt; 0x404028 &lt;main&gt;:	movl   $0x11223344,0x404039
   0x404033 &lt;main+11&gt;:	jmp    0x404035 &lt;main+13&gt;
   0x404035 &lt;main+13&gt;:	nop
   0x404036 &lt;mov_inst&gt;:	mov    $0x1,%rax
   0x40403d &lt;mov_inst+7&gt;:	retq   
</pre>

<p>
  書きかえたい対象の mov 命令のアドレスが0x404036(環境に依存して変わります)になっていて、
  それを書き変えるストアのmov 命令が、movl   $0x11223344,0x404039 (= 0x404036 + 3) になって、
  ラベルを参照していた命令のオペランドが、確定後のラベルのアドレスに書き換わっている点を確認しよう。
</p>

<p> (よくわからなければ、先にリンカの説明を見たほうがいいかもしれない (注:まだリンカの説明は書いてない)) </p>

<p>
  さて、命令は単なるバイト列だというのが確認できたところで、次へ進もう。次は分岐命令だ。

  分岐命令は、プログラムの流れを変える命令で、高級言語から使えるループ、if文、関数などを実現するために使われている。
</p>

<p
  まずは、単純な分岐命令から見ていこう。
  分岐命令は、プログラムカウンタに、オペランドで指定したアドレスを格納する命令だ。
</p>

<p>
  通常、命令実行後、プログラムカウンタは命令サイズ分インクリメントされて次の命令のアドレスを指すようになるが、
  分岐命令の実行後は、次の命令ではなく、オペランドで指定されたアドレスを指すようになり、
  次の命令は、そこから実行される。
</p>

<p> <a href="1/branch.s"> 1/branch.s </a> </p>

<pre> 
	.globl	main
main:
	mov	$0, %rax

loop:
	add	$1, %rax
	jmp	loop
</pre>

<p>
  x86_64 では、分岐命令の名前は "jmp" になっている。
  このプログラムを実行してみよう。
</p>

<pre>
(gdb) display /1i $pc
1: x/i $pc
&lt;error: No registers.&gt;
(gdb) display $pc
2: $pc = &lt;error: No registers.&gt;
(gdb) display $rax
3: $rax = &lt;error: No registers.&gt;
(gdb) start
Temporary breakpoint 1 at 0x401106
Starting program: /home/w0/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x0000000000401106 in main ()
1: x/i $pc
=&gt; 0x401106 &lt;main&gt;:	mov    $0x0,%rax
2: $pc = (void (*)()) 0x401106 &lt;main&gt;
3: $rax = 4198662
(gdb) stepi
0x000000000040110d in loop ()
1: x/i $pc
=&gt; 0x40110d &lt;loop&gt;:	add    $0x1,%rax
2: $pc = (void (*)()) 0x40110d &lt;loop&gt;
3: $rax = 0
(gdb) 
0x0000000000401111 in loop ()
1: x/i $pc
=&gt; 0x401111 &lt;loop+4&gt;:	jmp    0x40110d &lt;loop&gt;
2: $pc = (void (*)()) 0x401111 &lt;loop+4&gt;
3: $rax = 1
(gdb) 
0x000000000040110d in loop ()
1: x/i $pc
=&gt; 0x40110d &lt;loop&gt;:	add    $0x1,%rax
2: $pc = (void (*)()) 0x40110d &lt;loop&gt;
3: $rax = 1
(gdb) 
0x0000000000401111 in loop ()
1: x/i $pc
=&gt; 0x401111 &lt;loop+4&gt;:	jmp    0x40110d &lt;loop&gt;
2: $pc = (void (*)()) 0x401111 &lt;loop+4&gt;
3: $rax = 2
(gdb) 
0x000000000040110d in loop ()
1: x/i $pc
=&gt; 0x40110d &lt;loop&gt;:	add    $0x1,%rax
2: $pc = (void (*)()) 0x40110d &lt;loop&gt;
3: $rax = 2
(gdb) 
</pre>

<p>
  stepi を繰り返すと、プログラムカウンタが、loop ラベルの付いた命令にもどって、何度もadd命令を繰り返し実行し、raxレジスタの値が一個ずつ増えていくことを確認しよう。
</p>

<p>
  プログラムカウンタの値も単なる整数だ。rax などの汎用レジスタに格納された整数値(アドレス)を、プログラムカウンタにコピーすることもできる。
  汎用レジスタが指すアドレスへの分岐を、<em>間接分岐 (indirect branch)</em> と呼ぶ。
</p>

<p> <a href="1/indirect-branch.s"> 1/indirect-branch.s </a> </p>

<pre>
	.globl	main
main:
	mov	$loop, %rcx

	mov	$0, %rax

loop:
	add	$1, %rax
	jmp	*%rcx
</pre>

<p>
  loopラベルのアドレス値を、rcxレジスタに入れ、最後に jmp 命令を使って rcx レジスタの値をプログラムカウンタへコピーし、プログラムの流れをloopラベルが指す位置に戻している。これもgdbで実行して動作を確認しておいてほしい。
</p>

<p> "mov $loop, %rax"というのは、少しわかりにくいかもしれない。この x86_64 アセンブリ言語固有のわかりにくい点について説明しておこう。 </p>

<p> 
  x86_64 では、オペランドの数字文字列に "$" を付けるか付けないかは大きな違いがある。
  "$" が付いていればそのオペランドは即値、"$" が付いていなければそのオペランドはアドレス値だ。
</p>

<pre>
  mov 16, %rax  // アドレス値 16 から、64bit 値をロードしてraxに格納する
  mov $16, %rax // 即値16をraxに格納する
</pre>

<p>
  これは、とにかく紛らわしくて、慣れても何度も間違えてしまうのだが、間違えないように注意してほしい。
</p>

<p>
  このルールは、ラベルにも適用されて、"$"が付いたら即値、"$"が付かなければメモリオペランドだ。
</p>

<pre>
  mov label, %rax  // リンク後解決された label のアドレス値からロード
  mov $label, %rax // リンク後解決された label のアドレスを即値としてレジスタに格納
</pre>

<p>
  上の例では、
</p>

<pre>
	mov	$loop, %rcx
</pre>

<p> と、書いているが、これは、「loopラベルが置かれたアドレスの値を即値として rcx に格納する」という意味だ。 </p>

<p> ここで、"$" を書き忘れると、</p>

<pre>
	mov	loop, %rcx
</pre>

<p> 「loopラベルが置かれたアドレスから64bit 値をロードして、rcxに格納する」という意味になる。このふたつは、*意味が全く違う* 点に注意してほしい。 </p>

<p>(x86系以外の多くのCPUでは、ロード命令と即値movに別のニーモニックが割り当てられていることが多いので、もっと区別しやすい) </p>


<p>
  続いて説明するのは、<em>条件分岐命令</em> だ。
</p>

<p>
  上の分岐命令を使ったプログラムは、無限ループになっていて、一旦実行すると終了しない。
  これをもう少し発展させよう。
</p>

<p> <a href="1/sum.s"> 1/sum.s </a> </p>

<pre>
	.globl main

main:
	mov	$10, %rcx
	mov	$0, %rax

loop:
	add	%rcx, %rax
	sub	$1, %rcx
	jnz	loop

end:
	ret

</pre>

<p>
  これは、1〜10 までの総和 を求めるプログラムだ。gdbで以下のようにすれば rax が 55 になることが確認できる。
</p>


<pre>
(gdb) start
Temporary breakpoint 1 at 0x401106
Starting program: /home/w0/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x0000000000401106 in main ()
(gdb) break end
Breakpoint 2 at 0x40111d
(gdb) continue
Continuing.

Breakpoint 2, 0x000000000040111d in end ()
(gdb) p $rax
$1 = 55
(gdb) 
</pre>

<p> 
  また新たな gdb のコマンドを使っているので説明しておこう。breakとcontinueだ。
</p>

<p>
  "break" コマンドは、コマンド引数に渡したアドレスに <em>ブレークポイント</em> と呼ばれるものを設定するコマンドだ。
  このアドレスには、ラベルも使える。上の例では "break end" と書いたが、これは、end ラベルが置かれたアドレスに<em>ブレークポイント</em>を設定する。
  "break" コマンドは、非常によく使うコマンドなので、1文字で書くことができて、"b" でもよい。
</p>

<p>
  "continue" コマンドは、"break"コマンドで設定した<em>ブレークポイント</em> まで、プログラムの実行を進めるコマンドだ。
  上の例では、直前に end: ラベルの位置に、ブレークポイントを設定したので、その位置までプログラムを進める。
</p>

<p>
  上のgdbの結果は、プログラムカウンタが end ラベルに到達したときに、rax の値を表示すると 55 が表示されるという結果だ。
</p>


<p> 
  分岐の説明にもどろう。
  jnz 命令は、<em>条件分岐命令 (conditional branch)</em> と呼ばれる命令の一種だ。
  <em>条件分岐命令</em> は演算の結果(条件)を見て、条件が成立した場合に、分岐する(オペランドの値をプログラムカウンタに格納する)命令である。
  使われる条件には色々あるが、jnz 命令では、直前の演算結果がゼロでなかった場合に分岐(jnz = Jump if Not Zero)する。
</p>

<p> プログラムの挙動を解説していこう。 </p>

<pre>
	mov	$10, %rcx
	mov	$0, %rax
</pre>

<p>まずRCX、RAXを初期化する。RCXは、ループカウンタとして、RAXは合計値を入れるレジスタとして使う。</p>

<pre>
	add	%rcx, %rax
</pre>

<p> 合計値をとりたいので、RCXをRAXに足す。 (RCXの値は下のsub命令で減っていくので、ここで加算する値は、10,9,8,...,1 というように減っていく)</p>

<pre>
	sub	$1, %rcx
	jnz	loop
</pre>

<p> RCXの値から1を引いて、その結果がゼロでなければ loop: ラベルが置かれたアドレスへジャンプ </p>

<pre>
end:
	ret
</pre>

<p>
  RCX の値が、ゼロになれば、終了。
</p>

<p> というプログラムだ。長くなるのでもう書かないが、納得するまでgdbで動作を確認してほしい。 </p>

<p>
  条件分岐命令について、もう少し詳しく説明しよう。条件分岐は、「演算の結果(条件)」を見る、と書いた。
  x86_64 では、この条件は、eflagsというフラグレジスタの値のことだ。
</p>

<p> レジスタの説明のところで、 </p>

<ul>
  <li> フラグレジスタ(またはステータスレジスタ) : 演算結果のうち、データではない結果を保持する。例えば、足し算の結果が、64bit値に収まらない場合、それを示す値が入れられる </li>
</ul>

<p> と、書いていた。x86_64 の eflags レジスタは、このフラグレジスタに該当するレジスタで、演算結果の追加情報を格納する (MIPSのようにフラグレジスタに該当するレジスタが無いアーキテクチャもある) </p>

<p> <a href="1/status0.s"> 1/status0.s  </a> </p>

<pre>
	.globl	main
main:
	mov $0xffffffffffffffff, %rax
	add $1, %rax
	ret
</pre>

<pre>
(gdb) start
Temporary breakpoint 1 at 0x4004d6
Starting program: /mnt/d/wsl/src/pllp/docs/1/a.out 

Temporary breakpoint 1, 0x00000000004004d6 in main ()
(gdb) stepi
0x00000000004004dd in main ()
(gdb) p $rax
$1 = -1
(gdb) p $eflags
$2 = [ PF ZF IF ]
(gdb) stepi
0x00000000004004e1 in main ()
(gdb) p $eflags
$3 = [ CF PF AF ZF IF ]
</pre>

<p>
  gdb のプロンプトから print $eflags すると eflags の値を確認できる。
  eflags は 32bit のレジスタだが、gdbは気を効かせて、各ビットの名前を表示してくれる。
</p>

<p>
  ユーザーが書くプログラムで重要なのは、CF,ZF と、ここでは消えているが、OF,ZFだ。
  PF, AF は、もう過去の遺物なので二度と見なくていい。
  他のフラグはOS、仮想マシンを書く人向けなので、ユーザーは見る必要はないだろう。
  (あ、DFがあった。DFは説明しないので各自で調べて)
</p>

<p> それぞれの簡単な意味は以下のとおりだ </p>

<ul>
  <li> CF : キャリーフラグ(加算結果の、最後の繰り上がり) </li>
  <li> ZF : ゼロフラグ (演算結果がゼロ) </li>
  <li> OF : オーバーフローフラグ(符号付きの値がオーバーフローした) </li>
  <li> SF : 符号フラグ (演算結果がマイナス) </li>
</ul>

<p>
  詳細な意味は、命令によって変わるので、詳しく知る必要がある場合は、Intel の命令マニュアルを読もう。
  (正直なところ、筆者も詳しく知る必要に迫られたことがないので、挙動を完全に把握しているわけではない)
</p>

<p>
  jnz 命令は、このうち、ZF を条件として使う条件分岐で、ZF フラグがセットされていなかった場合に、分岐する。
  他にも色々な条件分岐命令が用意されているが、それはC言語との対応を見るところで説明しよう。(注 : まだ書いてないです)
</p>

<pre>
	sub	$1, %rcx
	jnz	loop
</pre>

<p> もう一度この部分を見てみよう。sub 命令は結果がゼロになると、eflagsのZFをセットする。ゼロでない場合は、ZFをクリアする。 </p>

<p>
  jnz 命令は、eflags を見て、ZF がクリアされていれば、オペランドで指定されたアドレスへ分岐、
  ZF がセットされていれば、オペランドを無視して、直後にある命令を引き続き実行していく。
</p>

<p> つまり、上のように書くことで、RCX がゼロになるまで回り続けるループを表現できる。 </p>

<!--
<p> 比較について考えよう。整数なら比較は&gt;、&gt;=、&lt;、&lt;=、==、!= の6個だ。 </p>

<p>
  &gt;、&gt;=、&lt;、&lt;= の4個は、値の符号の有無で挙動が変わる点に注意しよう。8bit値、0xff と 0x00 を比較した場合、
  これを符号付き値と見るなら、-1(0xff) と 0(0x00) の比較で、0x00 のほうが大きいが、
  符号無しの値と見るなら、255(0xff) と 0(0x00) の比較で、0xff のほうが大きい。
  つまり、整数を表現するビット列の比較には、10種類の方法がある。
</p>

<p>
  このへんの説明がわからない人も、これだけ覚えておいてほしいが、<em>整数の比較には、減算が使える</em>。
</p>

<p>
  A - B という減算をした場合、
</p>

<ul>
  <li> 結果が負ならば、 A &lt; B </li>
  <li> 結果がゼロならば、B == A </li>
  <li> 結果が正ならば、 A &gt; B </li>
</ul>

<p> となる。 </p>

<p> CPUの減算は、結果レジスタを書きかえてしまうが、比較したい場合、これは貴重なレジスタの値を破壊してしまうので使いづらい。</p>
-->


<p id="kokomade"> (ここまで書いた )</p>

 <h2> x86_64 機械語入門 </h2>
  <h3> Intel マニュアルの読みかた </h3>
 <h2> ARMv7 プログラミング入門 </h2>

 <h2> リンカ </h2>

  <p>
    ついに、リンカの説明をするときが来た。
  </p>

  <p>
    ここに至るまでに、何度「リンカのところで説明する」と書いただろうか？
    ここまで読んできた人ならば、
    リンカというものが、なにやら色々やっているんだな、というのはわかってきたのではないかと思う。
  </p>

  <p>
    筆者が常々思っていることのひとつに、「C言語に関する書籍は、リンカの説明をおざなりにしすぎだ」というのがある。
  </p>
  <p>
    多くのC言語の書籍は、
  </p>
  <ol>
    <li> コンパイラがソースコードをアセンブリコードに変換します </li>
    <li> アセンブラがアセンブリコードを機械語に変換します </li>
    <li> リンカが機械語をリンクして実行ファイルが作られます </li>
  </ol>

  <p>
    と、いう解説がなされがちである。この説明を見たら、多くの人が、「え、リンクってなんですか？」と、思うに違いない。
  </p>
  <p>
    アセンブラには、「人間が読めるニーモニックを、機械が読める機械語に変換する」みたいな、最低限の説明が付くものの、
    リンカの説明は「リンクをします」のひとことだけである！
  </p>

  <p>
    ここでは、いつも雑な説明をされがちな、リンカについて説明をしていきたいと思う。
  </p>

  <p>
    C言語の言語仕様には、明示的にリンクについて書かれてはいないものの、
    extern 指定子など、言語仕様の一部に、リンクの処理を無視して説明できない仕様を含んでいるのは間違いない。
    リンクについて知れば、C言語への理解も、もう一歩深まるだろう。
  </p>

  <h3> リンクとはなにか </h3>
  <h3> ELF </h3>
  <h3> ldscript </h3>
  <h3> ローダ </h3>


 <h2> C言語とアセンブリ </h2>
  <h3> ABI, Calling Convention (呼び出し規約) </h3>
 <h2> OS呼び出し </h2>

 <h2> インタプリタ/コンパイラ </h2>

 <h2> おまけ : printf </h2>
 <h2> おまけ : shellcode,PIC,PIE,ASLR </h2>

<h1> バス、メモリ、周辺IO、MMIO </h1>

<h1> Linux デバイスドライバ </h1>

<p>
  低レベルプログラミングを習得するためにLinux デバイスドライバについて学習するのは良い方法かもしれない。
</p>

<p>
  普段は、様々な問題からプログラマを守ってくれるOSではあるが、
  道を外したプログラミングをする場合、このOSの保護が邪魔になる場合がある。
</p>

<p>
  OSの保護を回避する手段として、「OSなし(ベアメタル)プログラミング」という世界がある。
  これは、非常に楽しいプログラミングではあるが、場合によってはprintfで数値を画面に出力したり、mallocでメモリを確保するだけでも
  かなりの苦労を伴う手法である。
</p>

<p>
  そこで、別の方法として、Linuxデバイスドライバを書くという方法もある。
</p>

<p>
  Linuxデバイスドライバまわりの開発環境は、非常によく整備されていて、
  printf ぐらい気軽に文字列を出力できるし、mallocぐらい気軽にメモリを割り当てられるし、
  プログラムにミスがあってエラーが出れば、エラーが発生した箇所を教えてくれる機能が付いている。
  「Linuxデバイスドライバ」という、優れた書籍があるのも嬉しい点だ。
</p>

<p>
  また、Linuxデバイスドライバについて深く学ぶと、演習で使うようなtoy OSにはない、
  現実世界で広く使われるOSに必要なものを肌で感じられるようになるというメリットもある
  (例えば、toyOSではCPUの速度に迫るような高速な周辺デバイスのことは考えられていないなど)。
  あと現実的な話をしてしまうと、Linuxドライバを書いてほしい/修正してほしいという仕事は世の中にたくさんあり、
  Linuxドライバが書けるようになっていると、職にあぶれないという点も見逃せない。
</p>

<p>
  この章では、本文書の説明で使える程度の範囲内で、Linuxデバイスドライバの書きかたについて説明していく。
  より詳しい使いかたに興味がある人は、書籍や、Linuxのソースコードを参照してほしい。
</p>

  <h2> GPIOデバイスドライバ (みんな大好きLチカプログラミング) </h2>

<h1> UART による通信 </h1>

<h1> ベアメタルプログラミング </h1>

<p>
  低レベルプログラミングに興味がある人なら、OS自作や、ベアメタルプログラミングに手を出したことがある人も多いのではないだろうか。
</p>

<p>
  しかし、現在のPCのマザーボードには、昔のOSに匹敵するような巨大なソフトウェアが搭載されているのが普通で、
  もっと小さなハードウェアで実行されるベアメタルプログラムと比較すると、まだ厚いレイヤーの上で動くソフトウェアしか作れないという問題がある。

  PCベアメタルプログラミングに手を出したことがある人も、BIOSコールを使って、HDDにアクセスしたり、
  UEFIサービスを使って、ファイルシステムにアクセスするとき、「これは何か求めていたものとは違うのではないか？」と思いながらプログラムを書いていたはずだ。
</p>

<p>
  ここでは、PCよりもレイヤーの薄いZyboを使って、ベアメタルプログラミングにチャレンジしていこうと思う。
  (ちなみにRaspberry Piも、大きめのファームウェアを持っていて、ARMがブートするのは、色々な初期化が終わったあとだ)
</p>

  <h2> ブートとは </h2>

  <h2> SPI flash </h2>

  <h2> クロック </h2>

  <h2> DRAMコントローラ </h2>

  <h2> ファームウェア、BIOS、UEFI </h2>

  <h2> おまけ : デバイスツリー </h2>

<h1> OSを支える技術 </h1>

 <h2> メモリ保護 </h2>
  <h3> 仮想化 </h3>

 <h2> 割り込み </h2>
  <h3> SMP </h3>

<h1> デバッガ </h1>

<h1> DMA </h1>

<h1> キャッシュ </h1>
 <h2> メモリ </h2>

<h1> 高速デバイスの世界 </h1>

<p>
  かつて、コンピュータというのは、高速なCPUと、中速なメモリ、低速なI/O から構成されていた。
</p>

<p>
  しかし、近年は、CPUの速度向上がかなり停滞してきているのに対し、
  周辺I/Oデバイスの速度向上は止まるどころか、高速なデバイスが次々に投入され、
  その性能は、CPUに迫るか、それを大きく上まわるものも登場してきた。
</p>

<p>
  遅いと言われていたストレージは、家庭用の物でもusec単位で処理が実行されており、
  100GbpsイーサやInfinibandの帯域はCPUのmemsetに迫るぐらいになり、
  GPUの演算スループット性能およびメモリ帯域はCPUの何倍も大きくなってきている。
</p>

<p>
  ここでは、現代の高速デバイスが、どのように接続され、ユーザからどのように使うのかといった点について解説していきたいと思う。
</p>

<h2> PCI Express </h2>

<h2> イーサネット </h2>

<h2> Infiniband </h2>

<h2> USB </h2>

<h2> GPU </h2>

<h2> ストレージ </h2>

 <h3> SATA, AHCI </h3>
 <h3> NVMe </h3>



<h1> ネットワーク </h1>

  <h2> TCP/IP </h2>

<h1> ファイルシステム </h1>

<h1> i2c </h1>

<h1> FPGA </h1>

<h1> RTC </h1>

<h1> ヒープ、malloc、GC </h1>

<h1> チューニング </h1>

<h1> 低レベルプログラミングに関する書籍 </h1>

</body>
</html>
